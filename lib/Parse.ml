(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_apex"

let parse_source_string ?src_file contents =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "line_comment";
  "block_comment";
]

let children_regexps : (string * Run.exp option) list = [
  "pat_side", None;
  "date_time", None;
  "pat_custom", None;
  "pat_find", None;
  "pat_super", None;
  "pat_using", None;
  "pat_final", None;
  "pat_suppos", None;
  "pat_fina", None;
  "pat_mine_and_my_groups", None;
  "date", None;
  "pat_view_", None;
  "pat_set", None;
  "pat_imples", None;
  "pat_merge", None;
  "pat_upsert", None;
  "pat_priv", None;
  "pat_next_fiscal_quar", None;
  "pat_today", None;
  "boolean_type", None;
  "pat_nulls", None;
  "pat_throw", None;
  "pat_test", None;
  "pat_inhe", None;
  "pat_maxd", None;
  "pat_count", None;
  "pat_null", None;
  "apex_identifier_", None;
  "pat_last_fiscal_year", None;
  "pat_yest", None;
  "pat_by", None;
  "pat_typeof", None;
  "pat_in", None;
  "pat_shar", None;
  "semgrep_metavar", None;
  "pat_day_only", None;
  "pat_false", None;
  "pat_first", None;
  "pat_week_in_year", None;
  "pat_last_year", None;
  "pat_at", None;
  "pat_rows", None;
  "pat_static", None;
  "pat_system_mode", None;
  "pat_true", None;
  "pat_insert", None;
  "pat_min", None;
  "decimal", None;
  "pat_where", None;
  "pat_ref", None;
  "pat_while", None;
  "pat_when", None;
  "pat_this_fiscal_year", None;
  "pat_having", None;
  "pat_trac", None;
  "pat_and", None;
  "pat_new", None;
  "pat_sum", None;
  "pat_offset", None;
  "pat_meta", None;
  "pat_mine", None;
  "pat_limit", None;
  "pat_next_year", None;
  "pat_team", None;
  "pat_try", None;
  "pat_delete", None;
  "pat_day_in_year", None;
  "pat_snip", None;
  "pat_reco", None;
  "term_separator_end", None;
  "pat_prot", None;
  "pat_inte", None;
  "dimensions",
  Some (
    Repeat1 (
      Seq [
        Token (Literal "[");
        Token (Literal "]");
      ];
    );
  );
  "pat_update", None;
  "pat_virt", None;
  "pat_name", None;
  "pat_before", None;
  "block_comment", None;
  "pat_if", None;
  "pat_spell_corr", None;
  "pat_on", None;
  "pat_catch", None;
  "pat_avg", None;
  "pat_else", None;
  "pat_hour_in_day", None;
  "pat_rollup", None;
  "pat_e8c36c5", None;
  "pat_week_in_month", None;
  "pat_like", None;
  "tok_choice_pat_last_n_days", None;
  "pat_next_fiscal_year", None;
  "pat_tomo", None;
  "pat_desc", None;
  "pat_retu", None;
  "pat_inst", None;
  "pat_select", None;
  "decimal_floating_point_literal", None;
  "pat_last_90_days", None;
  "pat_fiscal_year", None;
  "pat_phone", None;
  "pat_last_fiscal_quar", None;
  "pat_this_month", None;
  "term", None;
  "pat_asc", None;
  "pat_stan", None;
  "pat_fiscal_month", None;
  "pat_tola", None;
  "currency_literal", None;
  "pat_from", None;
  "pat_day_in_month", None;
  "pat_last_quar", None;
  "pat_dist", None;
  "pat_above_or_below", None;
  "pat_cube", None;
  "pat_user_mode", None;
  "pat_order", None;
  "pat_fields", None;
  "pat_tran", None;
  "pat_cale_month", None;
  "pat_this_quar", None;
  "pat_this_year", None;
  "pat_enum", None;
  "pat_count_dist", None;
  "pat_high", None;
  "pat_data", None;
  "pat_last", None;
  "semgrep_ellipsis", None;
  "pat_cale_quar", None;
  "pat_last_week", None;
  "pat_email", None;
  "pat_for", None;
  "pat_suppos_", None;
  "pat_pric", None;
  "pat_conv", None;
  "pat_this", None;
  "pat_abst", None;
  "pat_next_week", None;
  "pat_exclus", None;
  "pat_unde", None;
  "pat_this_week", None;
  "pat_view", None;
  "pat_fiscal_quar", None;
  "pat_my_team_terr", None;
  "pat_divi", None;
  "pat_trig", None;
  "pat_brk", None;
  "pat_above", None;
  "pat_last_month", None;
  "pat_format", None;
  "pat_target_len", None;
  "pat_all", None;
  "pat_over", None;
  "pat_then", None;
  "pat_void", None;
  "pat_next_quar", None;
  "pat_group", None;
  "pat_next_month", None;
  "pat_next_90_days", None;
  "pat_as", None;
  "pat_not", None;
  "pat_get", None;
  "pat_list", None;
  "pat_after", None;
  "pat_public", None;
  "pat_class", None;
  "pat_geol", None;
  "pat_secu_enfo", None;
  "pat_cont", None;
  "pat_inclus", None;
  "pat_max", None;
  "pat_my_terr", None;
  "pat_cale_year", None;
  "pat_ret", None;
  "pat_switch", None;
  "pat_userid", None;
  "pat_cate", None;
  "pat_do", None;
  "pat_ever", None;
  "pat_or", None;
  "pat_with_", None;
  "pat_extends", None;
  "pat_global", None;
  "term_separator_start", None;
  "string_literal", None;
  "int", None;
  "pat_end", None;
  "pat_netw", None;
  "pat_this_fiscal_quar", None;
  "property_navigation",
  Some (
    Seq [
      Opt (
        Token (Literal "?");
      );
      Token (Literal ".");
    ];
  );
  "pat_grou", None;
  "line_comment", None;
  "pat_with", None;
  "pat_scope", None;
  "pat_below", None;
  "pat_day_in_week", None;
  "semgrep_metavar_ellipsis", None;
  "pat_dele", None;
  "super", Some (Token (Name "pat_super"););
  "count_expression",
  Some (
    Seq [
      Token (Name "pat_count");
      Token (Literal "(");
      Token (Literal ")");
    ];
  );
  "null_literal", Some (Token (Name "pat_null"););
  "identifier",
  Some (
    Alt [|
      Token (Name "semgrep_metavar");
      Token (Name "apex_identifier_");
    |];
  );
  "boolean",
  Some (
    Alt [|
      Token (Name "pat_true");
      Token (Name "pat_false");
    |];
  );
  "update_type",
  Some (
    Alt [|
      Token (Name "pat_trac");
      Token (Name "pat_view_");
    |];
  );
  "value_comparison_operator",
  Some (
    Alt [|
      Token (Literal "=");
      Token (Literal "!=");
      Token (Literal "<>");
      Token (Literal "<");
      Token (Literal "<=");
      Token (Literal ">");
      Token (Literal ">=");
      Token (Name "pat_like");
    |];
  );
  "order_direction",
  Some (
    Alt [|
      Token (Name "pat_asc");
      Token (Name "pat_desc");
    |];
  );
  "with_highlight", Some (Token (Name "pat_high"););
  "order_null_direciton",
  Some (
    Alt [|
      Seq [
        Token (Name "pat_nulls");
        Token (Name "pat_first");
      ];
      Seq [
        Token (Name "pat_nulls");
        Token (Name "pat_last");
      ];
    |];
  );
  "this", Some (Token (Name "pat_this"););
  "dml_type",
  Some (
    Alt [|
      Token (Name "pat_insert");
      Token (Name "pat_update");
      Token (Name "pat_delete");
      Token (Name "pat_unde");
    |];
  );
  "for_type",
  Some (
    Alt [|
      Token (Name "pat_update");
      Token (Name "pat_ref");
      Token (Name "pat_view");
    |];
  );
  "all_rows_clause",
  Some (
    Seq [
      Token (Name "pat_all");
      Token (Name "pat_rows");
    ];
  );
  "in_type",
  Some (
    Alt [|
      Token (Name "pat_all");
      Token (Name "pat_email");
      Token (Name "pat_name");
      Token (Name "pat_phone");
      Token (Name "pat_side");
    |];
  );
  "fields_type",
  Some (
    Alt [|
      Token (Name "pat_all");
      Token (Name "pat_custom");
      Token (Name "pat_stan");
    |];
  );
  "void_type", Some (Token (Name "pat_void"););
  "trigger_event",
  Some (
    Alt [|
      Seq [
        Token (Name "pat_before");
        Token (Name "pat_insert");
      ];
      Seq [
        Token (Name "pat_before");
        Token (Name "pat_update");
      ];
      Seq [
        Token (Name "pat_before");
        Token (Name "pat_delete");
      ];
      Seq [
        Token (Name "pat_after");
        Token (Name "pat_insert");
      ];
      Seq [
        Token (Name "pat_after");
        Token (Name "pat_update");
      ];
      Seq [
        Token (Name "pat_after");
        Token (Name "pat_delete");
      ];
      Seq [
        Token (Name "pat_after");
        Token (Name "pat_unde");
      ];
    |];
  );
  "set_comparison_operator",
  Some (
    Alt [|
      Token (Name "pat_in");
      Seq [
        Token (Name "pat_not");
        Token (Name "pat_in");
      ];
      Token (Name "pat_inclus");
      Token (Name "pat_exclus");
    |];
  );
  "with_pricebook_expression",
  Some (
    Seq [
      Token (Name "pat_pric");
      Token (Literal "=");
      Token (Name "string_literal");
    ];
  );
  "with_user_id_type",
  Some (
    Seq [
      Token (Name "pat_userid");
      Token (Literal "=");
      Token (Name "string_literal");
    ];
  );
  "with_metadata_expression",
  Some (
    Seq [
      Token (Name "pat_meta");
      Token (Literal "=");
      Token (Name "string_literal");
    ];
  );
  "date_literal_with_param",
  Some (
    Seq [
      Token (Name "tok_choice_pat_last_n_days");
      Token (Literal ":");
      Token (Name "int");
    ];
  );
  "with_snippet_expression",
  Some (
    Seq [
      Token (Name "pat_snip");
      Opt (
        Seq [
          Token (Literal "(");
          Token (Name "pat_target_len");
          Token (Literal "=");
          Token (Name "int");
          Token (Literal ")");
        ];
      );
    ];
  );
  "date_literal",
  Some (
    Alt [|
      Token (Name "pat_yest");
      Token (Name "pat_today");
      Token (Name "pat_tomo");
      Token (Name "pat_last_week");
      Token (Name "pat_this_week");
      Token (Name "pat_next_week");
      Token (Name "pat_last_month");
      Token (Name "pat_this_month");
      Token (Name "pat_next_month");
      Token (Name "pat_last_90_days");
      Token (Name "pat_next_90_days");
      Token (Name "pat_this_quar");
      Token (Name "pat_last_quar");
      Token (Name "pat_next_quar");
      Token (Name "pat_this_year");
      Token (Name "pat_last_year");
      Token (Name "pat_next_year");
      Token (Name "pat_this_fiscal_quar");
      Token (Name "pat_last_fiscal_quar");
      Token (Name "pat_next_fiscal_quar");
      Token (Name "pat_this_fiscal_year");
      Token (Name "pat_last_fiscal_year");
      Token (Name "pat_next_fiscal_year");
    |];
  );
  "modifier",
  Some (
    Alt [|
      Token (Name "pat_global");
      Token (Name "pat_public");
      Token (Name "pat_test");
      Token (Name "pat_prot");
      Token (Name "pat_over");
      Token (Name "pat_priv");
      Token (Name "pat_virt");
      Token (Name "pat_abst");
      Token (Name "pat_static");
      Token (Name "pat_final");
      Token (Name "pat_tran");
      Seq [
        Token (Name "pat_with");
        Token (Name "pat_shar");
      ];
      Seq [
        Token (Name "pat_with_");
        Token (Name "pat_shar");
      ];
      Seq [
        Token (Name "pat_inhe");
        Token (Name "pat_shar");
      ];
    |];
  );
  "with_data_cat_filter_type",
  Some (
    Alt [|
      Token (Name "pat_at");
      Token (Name "pat_above");
      Token (Name "pat_below");
      Token (Name "pat_above_or_below");
    |];
  );
  "function_name",
  Some (
    Alt [|
      Token (Name "pat_avg");
      Token (Name "pat_count");
      Token (Name "pat_count_dist");
      Token (Name "pat_min");
      Token (Name "pat_max");
      Token (Name "pat_sum");
      Token (Name "pat_grou");
      Token (Name "pat_format");
      Token (Name "pat_conv");
      Token (Name "pat_tola");
      Token (Name "pat_cale_month");
      Token (Name "pat_cale_quar");
      Token (Name "pat_cale_year");
      Token (Name "pat_day_in_month");
      Token (Name "pat_day_in_week");
      Token (Name "pat_day_in_year");
      Token (Name "pat_day_only");
      Token (Name "pat_fiscal_month");
      Token (Name "pat_fiscal_quar");
      Token (Name "pat_fiscal_year");
      Token (Name "pat_hour_in_day");
      Token (Name "pat_week_in_month");
      Token (Name "pat_week_in_year");
    |];
  );
  "using_scope_type",
  Some (
    Alt [|
      Token (Name "pat_dele");
      Token (Name "pat_ever");
      Token (Name "pat_mine");
      Token (Name "pat_mine_and_my_groups");
      Token (Name "pat_my_terr");
      Token (Name "pat_my_team_terr");
      Token (Name "pat_team");
    |];
  );
  "using_clause",
  Some (
    Seq [
      Token (Name "pat_using");
      Token (Name "pat_list");
      Token (Literal "=");
      Token (Name "identifier");
    ];
  );
  "variable_declarator_id",
  Some (
    Seq [
      Token (Name "identifier");
      Opt (
        Token (Name "dimensions");
      );
    ];
  );
  "continue_statement",
  Some (
    Seq [
      Token (Name "pat_cont");
      Opt (
        Token (Name "identifier");
      );
      Token (Literal ";");
    ];
  );
  "dotted_identifier",
  Some (
    Seq [
      Token (Name "identifier");
      Repeat1 (
        Seq [
          Token (Literal ".");
          Token (Name "identifier");
        ];
      );
    ];
  );
  "break_statement",
  Some (
    Seq [
      Token (Name "pat_brk");
      Opt (
        Token (Name "identifier");
      );
      Token (Literal ";");
    ];
  );
  "scoped_identifier",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "scoped_identifier");
      |];
      Token (Literal ".");
      Token (Name "identifier");
    ];
  );
  "with_spell_correction_expression",
  Some (
    Seq [
      Token (Name "pat_spell_corr");
      Token (Literal "=");
      Token (Name "boolean");
    ];
  );
  "literal",
  Some (
    Alt [|
      Token (Name "int");
      Token (Name "decimal_floating_point_literal");
      Token (Name "boolean");
      Token (Name "string_literal");
      Token (Name "null_literal");
    |];
  );
  "with_record_visibility_param",
  Some (
    Alt [|
      Seq [
        Token (Name "pat_maxd");
        Token (Literal "=");
        Token (Name "int");
      ];
      Seq [
        Token (Name "pat_suppos");
        Token (Literal "=");
        Token (Name "boolean");
      ];
      Seq [
        Token (Name "pat_suppos_");
        Token (Literal "=");
        Token (Name "boolean");
      ];
    |];
  );
  "update_clause",
  Some (
    Seq [
      Token (Name "pat_update");
      Token (Name "update_type");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "update_type");
        ];
      );
    ];
  );
  "for_clause",
  Some (
    Seq [
      Token (Name "pat_for");
      Token (Name "for_type");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "for_type");
        ];
      );
    ];
  );
  "in_clause",
  Some (
    Seq [
      Token (Name "pat_in");
      Token (Name "in_type");
      Token (Name "pat_fields");
    ];
  );
  "fields_expression",
  Some (
    Seq [
      Token (Name "pat_fields");
      Token (Literal "(");
      Token (Name "fields_type");
      Token (Literal ")");
    ];
  );
  "soql_literal",
  Some (
    Alt [|
      Token (Name "int");
      Token (Name "decimal");
      Token (Name "string_literal");
      Token (Name "date");
      Token (Name "date_time");
      Token (Name "boolean");
      Token (Name "date_literal");
      Token (Name "date_literal_with_param");
      Token (Name "currency_literal");
      Token (Name "null_literal");
    |];
  );
  "with_data_cat_filter",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Name "with_data_cat_filter_type");
      Alt [|
        Token (Name "identifier");
        Seq [
          Token (Literal "(");
          Token (Name "identifier");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "identifier");
            ];
          );
          Token (Literal ")");
        ];
      |];
    ];
  );
  "soql_using_clause",
  Some (
    Seq [
      Token (Name "pat_using");
      Token (Name "pat_scope");
      Token (Name "using_scope_type");
    ];
  );
  "storage_identifier",
  Some (
    Alt [|
      Token (Name "semgrep_ellipsis");
      Token (Name "semgrep_metavar_ellipsis");
      Alt [|
        Token (Name "identifier");
        Token (Name "dotted_identifier");
      |];
    |];
  );
  "field_identifier",
  Some (
    Alt [|
      Token (Name "identifier");
      Token (Name "dotted_identifier");
    |];
  );
  "field_list",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "dotted_identifier");
      |];
      Repeat (
        Seq [
          Token (Literal ",");
          Alt [|
            Token (Name "identifier");
            Token (Name "dotted_identifier");
          |];
        ];
      );
    ];
  );
  "with_record_visibility_expression",
  Some (
    Seq [
      Token (Name "pat_reco");
      Token (Literal "(");
      Token (Name "with_record_visibility_param");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "with_record_visibility_param");
        ];
      );
      Token (Literal ")");
    ];
  );
  "with_data_cat_expression",
  Some (
    Seq [
      Token (Name "pat_data");
      Token (Name "pat_cate");
      Token (Name "with_data_cat_filter");
      Repeat (
        Seq [
          Token (Name "pat_and");
          Token (Name "with_data_cat_filter");
        ];
      );
    ];
  );
  "storage_alias",
  Some (
    Seq [
      Token (Name "storage_identifier");
      Opt (
        Token (Name "pat_as");
      );
      Token (Name "identifier");
    ];
  );
  "else_expression",
  Some (
    Seq [
      Token (Name "pat_else");
      Token (Name "field_list");
    ];
  );
  "when_expression",
  Some (
    Seq [
      Token (Name "pat_when");
      Token (Name "identifier");
      Token (Name "pat_then");
      Token (Name "field_list");
    ];
  );
  "soql_with_type",
  Some (
    Alt [|
      Token (Name "pat_secu_enfo");
      Token (Name "pat_user_mode");
      Token (Name "pat_system_mode");
      Token (Name "with_record_visibility_expression");
      Token (Name "with_data_cat_expression");
      Token (Name "with_user_id_type");
    |];
  );
  "from_clause",
  Some (
    Seq [
      Token (Name "pat_from");
      Alt [|
        Token (Name "storage_identifier");
        Token (Name "storage_alias");
      |];
      Repeat (
        Seq [
          Token (Literal ",");
          Alt [|
            Token (Name "storage_identifier");
            Token (Name "storage_alias");
          |];
        ];
      );
    ];
  );
  "type_of_clause",
  Some (
    Seq [
      Token (Name "pat_typeof");
      Token (Name "identifier");
      Repeat (
        Token (Name "when_expression");
      );
      Opt (
        Token (Name "else_expression");
      );
      Token (Name "pat_end");
    ];
  );
  "soql_with_clause",
  Some (
    Seq [
      Token (Name "pat_with");
      Token (Name "soql_with_type");
    ];
  );
  "accessor_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Alt [|
        Token (Name "pat_get");
        Token (Name "pat_set");
      |];
      Alt [|
        Token (Name "block");
        Token (Literal ";");
      |];
    ];
  );
  "accessor_list",
  Some (
    Seq [
      Token (Literal "{");
      Repeat1 (
        Token (Name "accessor_declaration");
      );
      Token (Literal "}");
    ];
  );
  "alias_expression",
  Some (
    Seq [
      Token (Name "value_expression");
      Opt (
        Token (Name "pat_as");
      );
      Token (Name "identifier");
    ];
  );
  "and_expression",
  Some (
    Seq [
      Token (Name "condition_expression");
      Repeat1 (
        Seq [
          Token (Name "pat_and");
          Token (Name "condition_expression");
        ];
      );
    ];
  );
  "annotated_type",
  Some (
    Seq [
      Repeat1 (
        Token (Name "annotation");
      );
      Token (Name "unannotated_type");
    ];
  );
  "annotation",
  Some (
    Seq [
      Token (Literal "@");
      Alt [|
        Token (Name "identifier");
        Token (Name "scoped_identifier");
      |];
      Opt (
        Token (Name "annotation_argument_list");
      );
    ];
  );
  "annotation_argument_list",
  Some (
    Seq [
      Token (Literal "(");
      Alt [|
        Token (Name "element_value");
        Seq [
          Token (Name "annotation_key_value");
          Repeat (
            Seq [
              Opt (
                Token (Literal ",");
              );
              Token (Name "annotation_key_value");
            ];
          );
        ];
      |];
      Token (Literal ")");
    ];
  );
  "annotation_key_value",
  Some (
    Alt [|
      Token (Name "semgrep_ellipsis");
      Seq [
        Token (Name "identifier");
        Token (Literal "=");
        Token (Name "element_value");
      ];
    |];
  );
  "argument_list",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Alt [|
            Token (Name "semgrep_ellipsis");
            Token (Name "semgrep_metavar_ellipsis");
            Token (Name "expression");
          |];
          Repeat (
            Seq [
              Token (Literal ",");
              Alt [|
                Token (Name "semgrep_ellipsis");
                Token (Name "semgrep_metavar_ellipsis");
                Token (Name "expression");
              |];
            ];
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "array_access",
  Some (
    Seq [
      Token (Name "primary_expression");
      Token (Literal "[");
      Token (Name "expression");
      Token (Literal "]");
    ];
  );
  "array_creation_expression",
  Some (
    Seq [
      Token (Name "pat_new");
      Alt [|
        Token (Name "void_type");
        Token (Name "boolean_type");
        Token (Name "identifier");
        Token (Name "scoped_type_identifier");
        Token (Name "generic_type");
      |];
      Alt [|
        Seq [
          Repeat1 (
            Token (Name "dimensions_expr");
          );
          Opt (
            Token (Name "dimensions");
          );
        ];
        Seq [
          Token (Name "dimensions");
          Token (Name "array_initializer");
        ];
        Seq [
          Token (Name "array_initializer");
        ];
      |];
    ];
  );
  "array_initializer",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Seq [
          Alt [|
            Token (Name "expression");
            Token (Name "array_initializer");
          |];
          Repeat (
            Seq [
              Token (Literal ",");
              Alt [|
                Token (Name "expression");
                Token (Name "array_initializer");
              |];
            ];
          );
        ];
      );
      Token (Literal "}");
    ];
  );
  "array_type",
  Some (
    Seq [
      Token (Name "unannotated_type");
      Token (Name "dimensions");
    ];
  );
  "assignment_expression",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "field_access");
        Token (Name "array_access");
      |];
      Alt [|
        Token (Literal "=");
        Token (Literal "+=");
        Token (Literal "-=");
        Token (Literal "*=");
        Token (Literal "/=");
        Token (Literal "&=");
        Token (Literal "|=");
        Token (Literal "^=");
        Token (Literal "%=");
        Token (Literal "<<=");
        Token (Literal ">>=");
        Token (Literal ">>>=");
      |];
      Token (Name "expression");
    ];
  );
  "binary_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Token (Literal ">");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "<");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal ">=");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "<=");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "==");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "===");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "!=");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "<>");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "!==");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "&&");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "||");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "+");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "-");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "*");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "/");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "&");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "|");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "^");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "%");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "<<");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal ">>");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal ">>>");
        Token (Name "expression");
      ];
    |];
  );
  "block",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "statement");
      );
      Token (Literal "}");
    ];
  );
  "boolean_expression",
  Some (
    Alt [|
      Token (Name "and_expression");
      Token (Name "or_expression");
      Token (Name "not_expression");
      Token (Name "condition_expression");
    |];
  );
  "bound_apex_expression",
  Some (
    Seq [
      Token (Literal ":");
      Token (Name "expression");
    ];
  );
  "cast_expression",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "type");
      Token (Literal ")");
      Token (Name "expression");
    ];
  );
  "catch_clause",
  Some (
    Seq [
      Token (Name "pat_catch");
      Token (Literal "(");
      Token (Name "catch_formal_parameter");
      Token (Literal ")");
      Token (Name "block");
    ];
  );
  "catch_formal_parameter",
  Some (
    Alt [|
      Token (Name "semgrep_ellipsis");
      Seq [
        Opt (
          Token (Name "modifiers");
        );
        Token (Name "unannotated_type");
        Token (Name "variable_declarator_id");
      ];
    |];
  );
  "class_body",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Alt [|
          Token (Name "semgrep_ellipsis");
          Alt [|
            Token (Name "field_declaration");
            Token (Name "method_declaration");
            Token (Name "class_declaration");
            Token (Name "interface_declaration");
            Token (Name "enum_declaration");
            Token (Name "block");
            Token (Name "static_initializer");
            Token (Name "constructor_declaration");
            Token (Literal ";");
          |];
        |];
      );
      Token (Literal "}");
    ];
  );
  "class_declaration",
  Some (
    Seq [
      Token (Name "class_header");
      Token (Name "class_body");
    ];
  );
  "class_header",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Name "pat_class");
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameters");
      );
      Opt (
        Token (Name "superclass");
      );
      Opt (
        Token (Name "interfaces");
      );
    ];
  );
  "class_literal",
  Some (
    Seq [
      Token (Name "unannotated_type");
      Token (Literal ".");
      Token (Name "pat_class");
    ];
  );
  "comparison",
  Some (
    Alt [|
      Token (Name "value_comparison");
      Token (Name "set_comparison");
    |];
  );
  "comparison_expression",
  Some (
    Seq [
      Token (Name "value_expression");
      Token (Name "comparison");
    ];
  );
  "condition_expression",
  Some (
    Alt [|
      Token (Name "semgrep_metavar");
      Alt [|
        Seq [
          Token (Literal "(");
          Token (Name "boolean_expression");
          Token (Literal ")");
        ];
        Token (Name "comparison_expression");
      |];
    |];
  );
  "constant_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Name "unannotated_type");
      Token (Name "variable_declarator_list");
      Token (Literal ";");
    ];
  );
  "constructor_body",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Token (Name "explicit_constructor_invocation");
      );
      Repeat (
        Token (Name "statement");
      );
      Token (Literal "}");
    ];
  );
  "constructor_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Name "constructor_declarator");
      Token (Name "constructor_body");
    ];
  );
  "constructor_declarator",
  Some (
    Seq [
      Opt (
        Token (Name "type_parameters");
      );
      Token (Name "identifier");
      Token (Name "formal_parameters");
    ];
  );
  "declaration",
  Some (
    Alt [|
      Token (Name "class_declaration");
      Token (Name "trigger_declaration");
      Token (Name "interface_declaration");
      Token (Name "enum_declaration");
    |];
  );
  "dimensions_expr",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "expression");
      Token (Literal "]");
    ];
  );
  "dml_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "dml_type");
        Token (Name "expression");
      ];
      Seq [
        Token (Name "pat_upsert");
        Token (Name "expression");
        Opt (
          Token (Name "unannotated_type");
        );
      ];
      Seq [
        Token (Name "pat_merge");
        Token (Name "expression");
        Token (Literal " ");
        Token (Name "expression");
      ];
    |];
  );
  "do_statement",
  Some (
    Seq [
      Token (Name "pat_do");
      Token (Name "statement");
      Token (Name "pat_while");
      Token (Name "parenthesized_expression");
      Token (Literal ";");
    ];
  );
  "element_value",
  Some (
    Alt [|
      Token (Name "expression");
      Token (Name "element_value_array_initializer");
      Token (Name "annotation");
    |];
  );
  "element_value_array_initializer",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "element_value");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "element_value");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "}");
    ];
  );
  "enhanced_for_statement",
  Some (
    Seq [
      Token (Name "pat_for");
      Token (Literal "(");
      Opt (
        Token (Name "modifiers");
      );
      Token (Name "unannotated_type");
      Token (Name "variable_declarator_id");
      Token (Literal ":");
      Token (Name "expression");
      Token (Literal ")");
      Token (Name "statement");
    ];
  );
  "enum_body",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "enum_constant");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "enum_constant");
            ];
          );
        ];
      );
      Token (Literal "}");
    ];
  );
  "enum_constant",
  Some (
    Alt [|
      Token (Name "semgrep_ellipsis");
      Seq [
        Opt (
          Token (Name "modifiers");
        );
        Token (Name "identifier");
      ];
    |];
  );
  "enum_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Name "pat_enum");
      Token (Name "identifier");
      Opt (
        Token (Name "interfaces");
      );
      Token (Name "enum_body");
    ];
  );
  "explicit_constructor_invocation",
  Some (
    Seq [
      Alt [|
        Seq [
          Opt (
            Token (Name "type_arguments");
          );
          Alt [|
            Token (Name "this");
            Token (Name "super");
          |];
        ];
        Seq [
          Alt [|
            Token (Name "primary_expression");
          |];
          Token (Literal ".");
          Opt (
            Token (Name "type_arguments");
          );
          Token (Name "super");
        ];
      |];
      Token (Name "argument_list");
      Token (Literal ";");
    ];
  );
  "expression",
  Some (
    Alt [|
      Token (Name "assignment_expression");
      Token (Name "binary_expression");
      Token (Name "instanceof_expression");
      Token (Name "ternary_expression");
      Token (Name "update_expression");
      Token (Name "primary_expression");
      Token (Name "unary_expression");
      Token (Name "cast_expression");
      Token (Name "dml_expression");
      Token (Name "switch_expression");
    |];
  );
  "expression_statement",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal ";");
    ];
  );
  "extends_interfaces",
  Some (
    Seq [
      Token (Name "pat_extends");
      Token (Name "type_list");
    ];
  );
  "field_access",
  Some (
    Seq [
      Alt [|
        Token (Name "primary_expression");
        Token (Name "super");
      |];
      Opt (
        Seq [
          Token (Name "property_navigation");
          Token (Name "super");
        ];
      );
      Token (Name "property_navigation");
      Alt [|
        Token (Name "identifier");
        Token (Name "this");
      |];
    ];
  );
  "field_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Name "unannotated_type");
      Token (Name "variable_declarator_list");
      Alt [|
        Token (Name "accessor_list");
        Token (Literal ";");
      |];
    ];
  );
  "finally_clause",
  Some (
    Seq [
      Token (Name "pat_fina");
      Token (Name "block");
    ];
  );
  "find_clause",
  Some (
    Seq [
      Token (Name "pat_find");
      Alt [|
        Token (Name "bound_apex_expression");
        Seq [
          Token (Name "term_separator_start");
          Token (Name "term");
          Token (Name "term_separator_end");
        ];
      |];
    ];
  );
  "for_statement",
  Some (
    Seq [
      Token (Name "pat_for");
      Token (Literal "(");
      Alt [|
        Token (Name "semgrep_ellipsis");
        Seq [
          Alt [|
            Token (Name "local_variable_declaration");
            Seq [
              Opt (
                Seq [
                  Token (Name "expression");
                  Repeat (
                    Seq [
                      Token (Literal ",");
                      Token (Name "expression");
                    ];
                  );
                ];
              );
              Token (Literal ";");
            ];
          |];
          Opt (
            Token (Name "expression");
          );
          Token (Literal ";");
          Opt (
            Seq [
              Token (Name "expression");
              Repeat (
                Seq [
                  Token (Literal ",");
                  Token (Name "expression");
                ];
              );
            ];
          );
        ];
      |];
      Token (Literal ")");
      Token (Name "statement");
    ];
  );
  "formal_parameter",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Name "modifiers");
        );
        Token (Name "unannotated_type");
        Token (Name "variable_declarator_id");
      ];
      Token (Name "semgrep_ellipsis");
      Token (Name "semgrep_metavar_ellipsis");
    |];
  );
  "formal_parameters",
  Some (
    Seq [
      Token (Literal "(");
      Opt (
        Seq [
          Token (Name "formal_parameter");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "formal_parameter");
            ];
          );
        ];
      );
      Token (Literal ")");
    ];
  );
  "function_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "pat_dist");
        Token (Literal "(");
        Alt [|
          Token (Name "field_identifier");
          Token (Name "bound_apex_expression");
        |];
        Token (Literal ",");
        Token (Name "geo_location_type");
        Token (Literal ",");
        Token (Name "string_literal");
        Token (Literal ")");
      ];
      Seq [
        Token (Name "function_name");
        Token (Literal "(");
        Token (Name "value_expression");
        Token (Literal ")");
      ];
    |];
  );
  "generic_type",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "scoped_type_identifier");
      |];
      Token (Name "type_arguments");
    ];
  );
  "geo_location_type",
  Some (
    Alt [|
      Token (Name "field_identifier");
      Token (Name "bound_apex_expression");
      Seq [
        Token (Name "pat_geol");
        Token (Literal "(");
        Token (Name "decimal");
        Token (Literal ",");
        Token (Name "decimal");
        Token (Literal ")");
      ];
    |];
  );
  "group_by_clause",
  Some (
    Seq [
      Token (Name "pat_group");
      Token (Name "pat_by");
      Token (Name "group_by_expression");
      Opt (
        Token (Name "having_clause");
      );
    ];
  );
  "group_by_expression",
  Some (
    Alt [|
      Seq [
        Alt [|
          Token (Name "field_identifier");
          Token (Name "function_expression");
        |];
        Repeat (
          Seq [
            Token (Literal ",");
            Alt [|
              Token (Name "field_identifier");
              Token (Name "function_expression");
            |];
          ];
        );
      ];
      Seq [
        Alt [|
          Token (Name "pat_rollup");
          Token (Name "pat_cube");
        |];
        Token (Literal "(");
        Token (Name "field_identifier");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "field_identifier");
          ];
        );
        Token (Literal ")");
      ];
    |];
  );
  "having_and_expression",
  Some (
    Seq [
      Token (Name "having_condition_expression");
      Repeat1 (
        Seq [
          Token (Name "pat_and");
          Token (Name "having_condition_expression");
        ];
      );
    ];
  );
  "having_boolean_expression",
  Some (
    Alt [|
      Token (Name "having_and_expression");
      Token (Name "having_or_expression");
      Token (Name "having_not_expression");
      Token (Name "having_condition_expression");
    |];
  );
  "having_clause",
  Some (
    Seq [
      Token (Name "pat_having");
      Token (Name "having_boolean_expression");
    ];
  );
  "having_comparison",
  Some (
    Alt [|
      Token (Name "having_value_comparison");
      Token (Name "having_set_comparison");
    |];
  );
  "having_comparison_expression",
  Some (
    Seq [
      Token (Name "function_expression");
      Token (Name "having_comparison");
    ];
  );
  "having_condition_expression",
  Some (
    Alt [|
      Seq [
        Token (Literal "(");
        Token (Name "having_boolean_expression");
        Token (Literal ")");
      ];
      Token (Name "having_comparison_expression");
    |];
  );
  "having_not_expression",
  Some (
    Seq [
      Token (Name "pat_not");
      Token (Name "having_condition_expression");
    ];
  );
  "having_or_expression",
  Some (
    Seq [
      Token (Name "having_condition_expression");
      Repeat1 (
        Seq [
          Token (Name "pat_or");
          Token (Name "having_condition_expression");
        ];
      );
    ];
  );
  "having_set_comparison",
  Some (
    Seq [
      Token (Name "set_comparison_operator");
      Alt [|
        Seq [
          Token (Literal "(");
          Alt [|
            Token (Name "soql_literal");
            Token (Name "bound_apex_expression");
          |];
          Repeat (
            Seq [
              Token (Literal ",");
              Alt [|
                Token (Name "soql_literal");
                Token (Name "bound_apex_expression");
              |];
            ];
          );
          Token (Literal ")");
        ];
        Token (Name "bound_apex_expression");
      |];
    ];
  );
  "having_value_comparison",
  Some (
    Seq [
      Token (Name "value_comparison_operator");
      Alt [|
        Token (Name "soql_literal");
        Token (Name "bound_apex_expression");
      |];
    ];
  );
  "if_statement",
  Some (
    Seq [
      Token (Name "pat_if");
      Token (Name "parenthesized_expression");
      Token (Name "statement");
      Opt (
        Seq [
          Token (Name "pat_else");
          Token (Name "statement");
        ];
      );
    ];
  );
  "instanceof_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Name "pat_inst");
      Token (Name "type");
    ];
  );
  "interface_body",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Alt [|
          Token (Name "semgrep_ellipsis");
          Token (Name "constant_declaration");
          Token (Name "enum_declaration");
          Token (Name "method_declaration");
          Token (Name "class_declaration");
          Token (Name "interface_declaration");
          Token (Literal ";");
        |];
      );
      Token (Literal "}");
    ];
  );
  "interface_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Name "pat_inte");
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameters");
      );
      Opt (
        Token (Name "extends_interfaces");
      );
      Token (Name "interface_body");
    ];
  );
  "interfaces",
  Some (
    Seq [
      Token (Name "pat_imples");
      Token (Name "type_list");
    ];
  );
  "labeled_statement",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal ":");
      Token (Name "statement");
    ];
  );
  "limit_clause",
  Some (
    Seq [
      Token (Name "pat_limit");
      Alt [|
        Token (Name "int");
        Token (Name "bound_apex_expression");
      |];
    ];
  );
  "local_variable_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Name "unannotated_type");
      Token (Name "variable_declarator_list");
      Token (Literal ";");
    ];
  );
  "map_creation_expression",
  Some (
    Seq [
      Token (Name "pat_new");
      Alt [|
        Token (Name "void_type");
        Token (Name "boolean_type");
        Token (Name "identifier");
        Token (Name "scoped_type_identifier");
        Token (Name "generic_type");
      |];
      Token (Name "map_initializer");
    ];
  );
  "map_initializer",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "map_initializer_");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "map_initializer_");
            ];
          );
        ];
      );
      Token (Literal "}");
    ];
  );
  "map_initializer_",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "=>");
      Token (Name "expression");
    ];
  );
  "method_declaration",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Name "method_header");
      Alt [|
        Token (Name "block");
        Token (Literal ";");
      |];
    ];
  );
  "method_declarator",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Name "formal_parameters");
      Opt (
        Token (Name "dimensions");
      );
    ];
  );
  "method_header",
  Some (
    Seq [
      Opt (
        Seq [
          Token (Name "type_parameters");
          Repeat (
            Token (Name "annotation");
          );
        ];
      );
      Token (Name "unannotated_type");
      Token (Name "method_declarator");
    ];
  );
  "method_invocation",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Seq [
          Alt [|
            Token (Name "primary_expression");
            Token (Name "super");
          |];
          Token (Name "property_navigation");
          Opt (
            Seq [
              Token (Name "super");
              Token (Name "property_navigation");
            ];
          );
          Opt (
            Token (Name "type_arguments");
          );
          Token (Name "identifier");
        ];
      |];
      Token (Name "argument_list");
    ];
  );
  "modifiers",
  Some (
    Repeat1 (
      Alt [|
        Token (Name "annotation");
        Token (Name "modifier");
      |];
    );
  );
  "not_expression",
  Some (
    Seq [
      Token (Name "pat_not");
      Token (Name "condition_expression");
    ];
  );
  "object_creation_expression",
  Some (
    Token (Name "unqualified_object_creation_expression");
  );
  "offset_clause",
  Some (
    Seq [
      Token (Name "pat_offset");
      Alt [|
        Token (Name "int");
        Token (Name "bound_apex_expression");
      |];
    ];
  );
  "or_expression",
  Some (
    Seq [
      Token (Name "condition_expression");
      Repeat1 (
        Seq [
          Token (Name "pat_or");
          Token (Name "condition_expression");
        ];
      );
    ];
  );
  "order_by_clause",
  Some (
    Seq [
      Token (Name "pat_order");
      Token (Name "pat_by");
      Token (Name "order_expression");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "order_expression");
        ];
      );
    ];
  );
  "order_expression",
  Some (
    Seq [
      Token (Name "value_expression");
      Opt (
        Token (Name "order_direction");
      );
      Opt (
        Token (Name "order_null_direciton");
      );
    ];
  );
  "parenthesized_expression",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
    ];
  );
  "primary_expression",
  Some (
    Alt [|
      Alt [|
        Token (Name "literal");
        Token (Name "class_literal");
        Token (Name "this");
        Token (Name "identifier");
        Token (Name "parenthesized_expression");
        Token (Name "object_creation_expression");
        Token (Name "field_access");
        Token (Name "array_access");
        Token (Name "method_invocation");
        Token (Name "array_creation_expression");
        Token (Name "map_creation_expression");
        Token (Name "query_expression");
      |];
      Token (Name "semgrep_deep_expression");
    |];
  );
  "query_expression",
  Some (
    Seq [
      Token (Literal "[");
      Alt [|
        Token (Name "soql_query");
        Token (Name "sosl_query");
      |];
      Token (Literal "]");
    ];
  );
  "return_statement",
  Some (
    Seq [
      Token (Name "pat_ret");
      Opt (
        Token (Name "expression");
      );
      Token (Literal ";");
    ];
  );
  "returning_clause",
  Some (
    Seq [
      Token (Name "pat_retu");
      Token (Name "sobject_return");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "sobject_return");
        ];
      );
    ];
  );
  "run_as_statement",
  Some (
    Seq [
      Token (Name "pat_e8c36c5");
      Token (Name "parenthesized_expression");
      Token (Name "block");
    ];
  );
  "scoped_type_identifier",
  Some (
    Seq [
      Alt [|
        Token (Name "identifier");
        Token (Name "scoped_type_identifier");
        Token (Name "generic_type");
      |];
      Token (Literal ".");
      Repeat (
        Token (Name "annotation");
      );
      Token (Name "identifier");
    ];
  );
  "select_clause",
  Some (
    Seq [
      Token (Name "pat_select");
      Alt [|
        Token (Name "count_expression");
        Seq [
          Token (Name "selectable_expression");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "selectable_expression");
            ];
          );
        ];
      |];
    ];
  );
  "selectable_expression",
  Some (
    Alt [|
      Token (Name "semgrep_ellipsis");
      Token (Name "semgrep_metavar_ellipsis");
      Alt [|
        Token (Name "value_expression");
        Token (Name "alias_expression");
        Token (Name "type_of_clause");
        Token (Name "fields_expression");
        Token (Name "subquery");
      |];
    |];
  );
  "selected_fields",
  Some (
    Seq [
      Token (Name "selectable_expression");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "selectable_expression");
        ];
      );
    ];
  );
  "semgrep_deep_expression",
  Some (
    Seq [
      Token (Literal "<...");
      Token (Name "expression");
      Token (Literal "...>");
    ];
  );
  "set_comparison",
  Some (
    Seq [
      Token (Name "set_comparison_operator");
      Alt [|
        Token (Name "subquery");
        Seq [
          Token (Literal "(");
          Alt [|
            Token (Name "soql_literal");
            Token (Name "bound_apex_expression");
          |];
          Repeat (
            Seq [
              Token (Literal ",");
              Alt [|
                Token (Name "soql_literal");
                Token (Name "bound_apex_expression");
              |];
            ];
          );
          Token (Literal ")");
        ];
        Token (Name "bound_apex_expression");
      |];
    ];
  );
  "sobject_return",
  Some (
    Seq [
      Token (Name "identifier");
      Opt (
        Seq [
          Token (Literal "(");
          Token (Name "selected_fields");
          Opt (
            Token (Name "using_clause");
          );
          Opt (
            Token (Name "where_clause");
          );
          Opt (
            Token (Name "order_by_clause");
          );
          Opt (
            Token (Name "limit_clause");
          );
          Opt (
            Token (Name "offset_clause");
          );
          Token (Literal ")");
        ];
      );
    ];
  );
  "soql_query",
  Some (
    Seq [
      Token (Name "soql_query_body");
    ];
  );
  "soql_query_body",
  Some (
    Seq [
      Token (Name "select_clause");
      Token (Name "from_clause");
      Opt (
        Token (Name "soql_using_clause");
      );
      Opt (
        Token (Name "where_clause");
      );
      Opt (
        Token (Name "soql_with_clause");
      );
      Opt (
        Token (Name "group_by_clause");
      );
      Opt (
        Token (Name "order_by_clause");
      );
      Opt (
        Token (Name "limit_clause");
      );
      Opt (
        Token (Name "offset_clause");
      );
      Opt (
        Token (Name "for_clause");
      );
      Opt (
        Token (Name "update_clause");
      );
      Opt (
        Token (Name "all_rows_clause");
      );
    ];
  );
  "sosl_query",
  Some (
    Seq [
      Token (Name "sosl_query_body");
    ];
  );
  "sosl_query_body",
  Some (
    Seq [
      Token (Name "find_clause");
      Opt (
        Token (Name "in_clause");
      );
      Opt (
        Repeat (
          Token (Name "returning_clause");
        );
      );
      Opt (
        Repeat (
          Token (Name "sosl_with_clause");
        );
      );
      Opt (
        Token (Name "limit_clause");
      );
      Opt (
        Token (Name "offset_clause");
      );
      Opt (
        Token (Name "update_clause");
      );
    ];
  );
  "sosl_with_clause",
  Some (
    Seq [
      Token (Name "pat_with");
      Token (Name "sosl_with_type");
    ];
  );
  "sosl_with_type",
  Some (
    Alt [|
      Token (Name "with_data_cat_expression");
      Token (Name "with_division_expression");
      Token (Name "with_highlight");
      Token (Name "with_metadata_expression");
      Token (Name "with_network_expression");
      Token (Name "with_pricebook_expression");
      Token (Name "with_snippet_expression");
      Token (Name "with_spell_correction_expression");
    |];
  );
  "statement",
  Some (
    Alt [|
      Alt [|
        Token (Name "declaration");
        Token (Name "expression_statement");
        Token (Name "labeled_statement");
        Token (Name "if_statement");
        Token (Name "while_statement");
        Token (Name "for_statement");
        Token (Name "enhanced_for_statement");
        Token (Name "block");
        Token (Literal ";");
        Token (Name "do_statement");
        Token (Name "break_statement");
        Token (Name "continue_statement");
        Token (Name "return_statement");
        Token (Name "switch_expression");
        Token (Name "local_variable_declaration");
        Token (Name "throw_statement");
        Token (Name "try_statement");
        Token (Name "run_as_statement");
      |];
      Token (Name "semgrep_ellipsis");
    |];
  );
  "static_initializer",
  Some (
    Seq [
      Token (Name "pat_static");
      Token (Name "block");
    ];
  );
  "subquery",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "soql_query_body");
      Token (Literal ")");
    ];
  );
  "superclass",
  Some (
    Seq [
      Token (Name "pat_extends");
      Token (Name "type");
    ];
  );
  "switch_block",
  Some (
    Seq [
      Token (Literal "{");
      Repeat1 (
        Token (Name "switch_rule");
      );
      Token (Literal "}");
    ];
  );
  "switch_expression",
  Some (
    Seq [
      Token (Name "pat_switch");
      Token (Name "pat_on");
      Token (Name "expression");
      Token (Name "switch_block");
    ];
  );
  "switch_label",
  Some (
    Seq [
      Token (Name "pat_when");
      Alt [|
        Seq [
          Opt (
            Token (Name "unannotated_type");
          );
          Token (Name "identifier");
          Repeat (
            Seq [
              Token (Literal ",");
              Opt (
                Token (Name "unannotated_type");
              );
              Token (Name "identifier");
            ];
          );
        ];
        Seq [
          Token (Name "expression");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "expression");
            ];
          );
        ];
        Token (Name "pat_else");
      |];
    ];
  );
  "switch_rule",
  Some (
    Alt [|
      Token (Name "semgrep_ellipsis");
      Seq [
        Token (Name "switch_label");
        Token (Name "block");
      ];
    |];
  );
  "ternary_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "?");
      Token (Name "expression");
      Token (Literal ":");
      Token (Name "expression");
    ];
  );
  "throw_statement",
  Some (
    Seq [
      Token (Name "pat_throw");
      Token (Name "expression");
      Token (Literal ";");
    ];
  );
  "trigger_body", Some (Token (Name "block"););
  "trigger_declaration",
  Some (
    Seq [
      Token (Name "pat_trig");
      Token (Name "identifier");
      Token (Name "pat_on");
      Token (Name "identifier");
      Token (Literal "(");
      Token (Name "trigger_event");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "trigger_event");
        ];
      );
      Token (Literal ")");
      Token (Name "trigger_body");
    ];
  );
  "try_statement",
  Some (
    Seq [
      Token (Name "pat_try");
      Token (Name "block");
      Alt [|
        Repeat1 (
          Token (Name "catch_clause");
        );
        Seq [
          Repeat (
            Token (Name "catch_clause");
          );
          Token (Name "finally_clause");
        ];
      |];
    ];
  );
  "type",
  Some (
    Alt [|
      Token (Name "unannotated_type");
      Token (Name "annotated_type");
    |];
  );
  "type_arguments",
  Some (
    Seq [
      Token (Literal "<");
      Opt (
        Seq [
          Token (Name "type");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "type");
            ];
          );
        ];
      );
      Token (Literal ">");
    ];
  );
  "type_bound",
  Some (
    Seq [
      Token (Name "pat_extends");
      Token (Name "type");
      Repeat (
        Seq [
          Token (Literal "&");
          Token (Name "type");
        ];
      );
    ];
  );
  "type_list",
  Some (
    Seq [
      Token (Name "type");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "type");
        ];
      );
    ];
  );
  "type_parameter",
  Some (
    Alt [|
      Token (Name "semgrep_ellipsis");
      Seq [
        Repeat (
          Token (Name "annotation");
        );
        Token (Name "identifier");
        Opt (
          Token (Name "type_bound");
        );
      ];
    |];
  );
  "type_parameters",
  Some (
    Seq [
      Token (Literal "<");
      Token (Name "type_parameter");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "type_parameter");
        ];
      );
      Token (Literal ">");
    ];
  );
  "unannotated_type",
  Some (
    Alt [|
      Alt [|
        Token (Name "void_type");
        Token (Name "boolean_type");
        Token (Name "identifier");
        Token (Name "scoped_type_identifier");
        Token (Name "generic_type");
      |];
      Token (Name "array_type");
    |];
  );
  "unary_expression",
  Some (
    Alt [|
      Seq [
        Token (Literal "+");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "-");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "!");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "~");
        Token (Name "expression");
      ];
    |];
  );
  "unqualified_object_creation_expression",
  Some (
    Seq [
      Token (Name "pat_new");
      Opt (
        Token (Name "type_arguments");
      );
      Alt [|
        Token (Name "void_type");
        Token (Name "boolean_type");
        Token (Name "identifier");
        Token (Name "scoped_type_identifier");
        Token (Name "generic_type");
      |];
      Token (Name "argument_list");
      Opt (
        Token (Name "class_body");
      );
    ];
  );
  "update_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Token (Literal "++");
      ];
      Seq [
        Token (Name "expression");
        Token (Literal "--");
      ];
      Seq [
        Token (Literal "++");
        Token (Name "expression");
      ];
      Seq [
        Token (Literal "--");
        Token (Name "expression");
      ];
    |];
  );
  "value_comparison",
  Some (
    Seq [
      Token (Name "value_comparison_operator");
      Alt [|
        Token (Name "soql_literal");
        Token (Name "bound_apex_expression");
      |];
    ];
  );
  "value_expression",
  Some (
    Alt [|
      Token (Name "function_expression");
      Token (Name "field_identifier");
    |];
  );
  "variable_declarator",
  Some (
    Seq [
      Token (Name "variable_declarator_id");
      Opt (
        Seq [
          Token (Literal "=");
          Alt [|
            Token (Name "expression");
            Token (Name "array_initializer");
          |];
        ];
      );
    ];
  );
  "variable_declarator_list",
  Some (
    Seq [
      Token (Name "variable_declarator");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "variable_declarator");
        ];
      );
    ];
  );
  "where_clause",
  Some (
    Seq [
      Token (Name "pat_where");
      Token (Name "boolean_expression");
    ];
  );
  "while_statement",
  Some (
    Seq [
      Token (Name "pat_while");
      Token (Name "parenthesized_expression");
      Token (Name "statement");
    ];
  );
  "with_division_expression",
  Some (
    Seq [
      Token (Name "pat_divi");
      Token (Literal "=");
      Alt [|
        Token (Name "bound_apex_expression");
        Token (Name "string_literal");
      |];
    ];
  );
  "with_network_expression",
  Some (
    Seq [
      Token (Name "pat_netw");
      Token (Name "comparison");
    ];
  );
  "partial_try",
  Some (
    Seq [
      Token (Name "pat_try");
      Token (Name "block");
    ];
  );
  "partial_finally", Some (Token (Name "finally_clause"););
  "partial_catch", Some (Token (Name "catch_clause"););
  "partial_if",
  Some (
    Seq [
      Token (Name "pat_if");
      Token (Name "parenthesized_expression");
    ];
  );
  "full_method_header",
  Some (
    Seq [
      Opt (
        Token (Name "modifiers");
      );
      Token (Name "method_header");
    ];
  );
  "parser_output",
  Some (
    Alt [|
      Repeat (
        Token (Name "statement");
      );
      Token (Name "constructor_declaration");
      Token (Name "expression");
      Token (Name "annotation");
      Token (Name "method_declaration");
      Token (Name "local_variable_declaration");
      Token (Name "class_header");
      Token (Name "full_method_header");
      Token (Name "partial_if");
      Token (Name "partial_try");
      Token (Name "partial_catch");
      Token (Name "partial_finally");
    |];
  );
]

let trans_pat_side ((kind, body) : mt) : CST.pat_side =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_date_time ((kind, body) : mt) : CST.date_time =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_custom ((kind, body) : mt) : CST.pat_custom =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_find ((kind, body) : mt) : CST.pat_find =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_super ((kind, body) : mt) : CST.pat_super =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_using ((kind, body) : mt) : CST.pat_using =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_final ((kind, body) : mt) : CST.pat_final =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_suppos ((kind, body) : mt) : CST.pat_suppos =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_fina ((kind, body) : mt) : CST.pat_fina =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_mine_and_my_groups ((kind, body) : mt) : CST.pat_mine_and_my_groups =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_date ((kind, body) : mt) : CST.date =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_view_ ((kind, body) : mt) : CST.pat_view_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_set ((kind, body) : mt) : CST.pat_set =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_imples ((kind, body) : mt) : CST.pat_imples =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_merge ((kind, body) : mt) : CST.pat_merge =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_upsert ((kind, body) : mt) : CST.pat_upsert =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_priv ((kind, body) : mt) : CST.pat_priv =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_next_fiscal_quar ((kind, body) : mt) : CST.pat_next_fiscal_quar =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_today ((kind, body) : mt) : CST.pat_today =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_boolean_type ((kind, body) : mt) : CST.boolean_type =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_nulls ((kind, body) : mt) : CST.pat_nulls =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_throw ((kind, body) : mt) : CST.pat_throw =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_test ((kind, body) : mt) : CST.pat_test =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_inhe ((kind, body) : mt) : CST.pat_inhe =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_maxd ((kind, body) : mt) : CST.pat_maxd =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_count ((kind, body) : mt) : CST.pat_count =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_null ((kind, body) : mt) : CST.pat_null =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_apex_identifier_ ((kind, body) : mt) : CST.apex_identifier_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_last_fiscal_year ((kind, body) : mt) : CST.pat_last_fiscal_year =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_yest ((kind, body) : mt) : CST.pat_yest =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_by ((kind, body) : mt) : CST.pat_by =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_typeof ((kind, body) : mt) : CST.pat_typeof =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_in ((kind, body) : mt) : CST.pat_in =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_shar ((kind, body) : mt) : CST.pat_shar =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_semgrep_metavar ((kind, body) : mt) : CST.semgrep_metavar =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_day_only ((kind, body) : mt) : CST.pat_day_only =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_false ((kind, body) : mt) : CST.pat_false =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_first ((kind, body) : mt) : CST.pat_first =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_week_in_year ((kind, body) : mt) : CST.pat_week_in_year =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_last_year ((kind, body) : mt) : CST.pat_last_year =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_at ((kind, body) : mt) : CST.pat_at =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_rows ((kind, body) : mt) : CST.pat_rows =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_static ((kind, body) : mt) : CST.pat_static =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_system_mode ((kind, body) : mt) : CST.pat_system_mode =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_true ((kind, body) : mt) : CST.pat_true =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_insert ((kind, body) : mt) : CST.pat_insert =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_min ((kind, body) : mt) : CST.pat_min =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_decimal ((kind, body) : mt) : CST.decimal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_where ((kind, body) : mt) : CST.pat_where =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_ref ((kind, body) : mt) : CST.pat_ref =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_while ((kind, body) : mt) : CST.pat_while =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_when ((kind, body) : mt) : CST.pat_when =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_this_fiscal_year ((kind, body) : mt) : CST.pat_this_fiscal_year =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_having ((kind, body) : mt) : CST.pat_having =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_trac ((kind, body) : mt) : CST.pat_trac =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_and ((kind, body) : mt) : CST.pat_and =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_new ((kind, body) : mt) : CST.pat_new =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_sum ((kind, body) : mt) : CST.pat_sum =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_offset ((kind, body) : mt) : CST.pat_offset =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_meta ((kind, body) : mt) : CST.pat_meta =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_mine ((kind, body) : mt) : CST.pat_mine =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_limit ((kind, body) : mt) : CST.pat_limit =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_next_year ((kind, body) : mt) : CST.pat_next_year =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_team ((kind, body) : mt) : CST.pat_team =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_try ((kind, body) : mt) : CST.pat_try =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_delete ((kind, body) : mt) : CST.pat_delete =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_day_in_year ((kind, body) : mt) : CST.pat_day_in_year =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_snip ((kind, body) : mt) : CST.pat_snip =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_reco ((kind, body) : mt) : CST.pat_reco =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_term_separator_end ((kind, body) : mt) : CST.term_separator_end =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_prot ((kind, body) : mt) : CST.pat_prot =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_inte ((kind, body) : mt) : CST.pat_inte =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_dimensions ((kind, body) : mt) : CST.dimensions =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Seq [v0; v1] ->
              (
                Run.trans_token (Run.matcher_token v0),
                Run.trans_token (Run.matcher_token v1)
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

let trans_pat_update ((kind, body) : mt) : CST.pat_update =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_virt ((kind, body) : mt) : CST.pat_virt =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_name ((kind, body) : mt) : CST.pat_name =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_before ((kind, body) : mt) : CST.pat_before =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_block_comment ((kind, body) : mt) : CST.block_comment =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_if ((kind, body) : mt) : CST.pat_if =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_spell_corr ((kind, body) : mt) : CST.pat_spell_corr =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_on ((kind, body) : mt) : CST.pat_on =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_catch ((kind, body) : mt) : CST.pat_catch =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_avg ((kind, body) : mt) : CST.pat_avg =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_else ((kind, body) : mt) : CST.pat_else =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_hour_in_day ((kind, body) : mt) : CST.pat_hour_in_day =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_rollup ((kind, body) : mt) : CST.pat_rollup =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_e8c36c5 ((kind, body) : mt) : CST.pat_e8c36c5 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_week_in_month ((kind, body) : mt) : CST.pat_week_in_month =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_like ((kind, body) : mt) : CST.pat_like =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_tok_choice_pat_last_n_days ((kind, body) : mt) : CST.tok_choice_pat_last_n_days =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_next_fiscal_year ((kind, body) : mt) : CST.pat_next_fiscal_year =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_tomo ((kind, body) : mt) : CST.pat_tomo =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_desc ((kind, body) : mt) : CST.pat_desc =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_retu ((kind, body) : mt) : CST.pat_retu =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_inst ((kind, body) : mt) : CST.pat_inst =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_select ((kind, body) : mt) : CST.pat_select =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_decimal_floating_point_literal ((kind, body) : mt) : CST.decimal_floating_point_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_last_90_days ((kind, body) : mt) : CST.pat_last_90_days =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_fiscal_year ((kind, body) : mt) : CST.pat_fiscal_year =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_phone ((kind, body) : mt) : CST.pat_phone =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_last_fiscal_quar ((kind, body) : mt) : CST.pat_last_fiscal_quar =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_this_month ((kind, body) : mt) : CST.pat_this_month =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_term ((kind, body) : mt) : CST.term =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_asc ((kind, body) : mt) : CST.pat_asc =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_stan ((kind, body) : mt) : CST.pat_stan =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_fiscal_month ((kind, body) : mt) : CST.pat_fiscal_month =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_tola ((kind, body) : mt) : CST.pat_tola =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_currency_literal ((kind, body) : mt) : CST.currency_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_from ((kind, body) : mt) : CST.pat_from =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_day_in_month ((kind, body) : mt) : CST.pat_day_in_month =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_last_quar ((kind, body) : mt) : CST.pat_last_quar =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_dist ((kind, body) : mt) : CST.pat_dist =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_above_or_below ((kind, body) : mt) : CST.pat_above_or_below =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_cube ((kind, body) : mt) : CST.pat_cube =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_user_mode ((kind, body) : mt) : CST.pat_user_mode =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_order ((kind, body) : mt) : CST.pat_order =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_fields ((kind, body) : mt) : CST.pat_fields =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_tran ((kind, body) : mt) : CST.pat_tran =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_cale_month ((kind, body) : mt) : CST.pat_cale_month =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_this_quar ((kind, body) : mt) : CST.pat_this_quar =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_this_year ((kind, body) : mt) : CST.pat_this_year =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_enum ((kind, body) : mt) : CST.pat_enum =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_count_dist ((kind, body) : mt) : CST.pat_count_dist =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_high ((kind, body) : mt) : CST.pat_high =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_data ((kind, body) : mt) : CST.pat_data =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_last ((kind, body) : mt) : CST.pat_last =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_semgrep_ellipsis ((kind, body) : mt) : CST.semgrep_ellipsis =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_cale_quar ((kind, body) : mt) : CST.pat_cale_quar =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_last_week ((kind, body) : mt) : CST.pat_last_week =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_email ((kind, body) : mt) : CST.pat_email =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_for ((kind, body) : mt) : CST.pat_for =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_suppos_ ((kind, body) : mt) : CST.pat_suppos_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_pric ((kind, body) : mt) : CST.pat_pric =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_conv ((kind, body) : mt) : CST.pat_conv =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_this ((kind, body) : mt) : CST.pat_this =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_abst ((kind, body) : mt) : CST.pat_abst =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_next_week ((kind, body) : mt) : CST.pat_next_week =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_exclus ((kind, body) : mt) : CST.pat_exclus =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_unde ((kind, body) : mt) : CST.pat_unde =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_this_week ((kind, body) : mt) : CST.pat_this_week =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_view ((kind, body) : mt) : CST.pat_view =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_fiscal_quar ((kind, body) : mt) : CST.pat_fiscal_quar =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_my_team_terr ((kind, body) : mt) : CST.pat_my_team_terr =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_divi ((kind, body) : mt) : CST.pat_divi =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_trig ((kind, body) : mt) : CST.pat_trig =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_brk ((kind, body) : mt) : CST.pat_brk =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_above ((kind, body) : mt) : CST.pat_above =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_last_month ((kind, body) : mt) : CST.pat_last_month =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_format ((kind, body) : mt) : CST.pat_format =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_target_len ((kind, body) : mt) : CST.pat_target_len =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_all ((kind, body) : mt) : CST.pat_all =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_over ((kind, body) : mt) : CST.pat_over =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_then ((kind, body) : mt) : CST.pat_then =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_void ((kind, body) : mt) : CST.pat_void =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_pat_next_quar ((kind, body) : mt) : CST.pat_next_quar =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_group ((kind, body) : mt) : CST.pat_group =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_next_month ((kind, body) : mt) : CST.pat_next_month =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_next_90_days ((kind, body) : mt) : CST.pat_next_90_days =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_as ((kind, body) : mt) : CST.pat_as =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_not ((kind, body) : mt) : CST.pat_not =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_get ((kind, body) : mt) : CST.pat_get =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_list ((kind, body) : mt) : CST.pat_list =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_after ((kind, body) : mt) : CST.pat_after =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_public ((kind, body) : mt) : CST.pat_public =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_class ((kind, body) : mt) : CST.pat_class =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_geol ((kind, body) : mt) : CST.pat_geol =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_secu_enfo ((kind, body) : mt) : CST.pat_secu_enfo =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_cont ((kind, body) : mt) : CST.pat_cont =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_inclus ((kind, body) : mt) : CST.pat_inclus =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_max ((kind, body) : mt) : CST.pat_max =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_my_terr ((kind, body) : mt) : CST.pat_my_terr =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_cale_year ((kind, body) : mt) : CST.pat_cale_year =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_ret ((kind, body) : mt) : CST.pat_ret =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_switch ((kind, body) : mt) : CST.pat_switch =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_userid ((kind, body) : mt) : CST.pat_userid =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_cate ((kind, body) : mt) : CST.pat_cate =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_do ((kind, body) : mt) : CST.pat_do =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_ever ((kind, body) : mt) : CST.pat_ever =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_or ((kind, body) : mt) : CST.pat_or =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_with_ ((kind, body) : mt) : CST.pat_with_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_extends ((kind, body) : mt) : CST.pat_extends =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_global ((kind, body) : mt) : CST.pat_global =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_term_separator_start ((kind, body) : mt) : CST.term_separator_start =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_string_literal ((kind, body) : mt) : CST.string_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_int_ ((kind, body) : mt) : CST.int_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_end ((kind, body) : mt) : CST.pat_end =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_netw ((kind, body) : mt) : CST.pat_netw =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_this_fiscal_quar ((kind, body) : mt) : CST.pat_this_fiscal_quar =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_property_navigation ((kind, body) : mt) : CST.property_navigation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pat_grou ((kind, body) : mt) : CST.pat_grou =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_line_comment ((kind, body) : mt) : CST.line_comment =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_with ((kind, body) : mt) : CST.pat_with =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_scope ((kind, body) : mt) : CST.pat_scope =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_below ((kind, body) : mt) : CST.pat_below =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_day_in_week ((kind, body) : mt) : CST.pat_day_in_week =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_semgrep_metavar_ellipsis ((kind, body) : mt) : CST.semgrep_metavar_ellipsis =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_pat_dele ((kind, body) : mt) : CST.pat_dele =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_super ((kind, body) : mt) : CST.super =
  match body with
  | Children v ->
      trans_pat_super (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_count_expression ((kind, body) : mt) : CST.count_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_count (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_null_literal ((kind, body) : mt) : CST.null_literal =
  match body with
  | Children v ->
      trans_pat_null (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Semg_meta (
            trans_semgrep_metavar (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Apex_id_ (
            trans_apex_identifier_ (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_boolean ((kind, body) : mt) : CST.boolean =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_true (
            trans_pat_true (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_false (
            trans_pat_false (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_update_type ((kind, body) : mt) : CST.update_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_trac (
            trans_pat_trac (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_view_ (
            trans_pat_view_ (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_value_comparison_operator ((kind, body) : mt) : CST.value_comparison_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `EQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `BANGEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `LTGT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `LT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `LTEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `GT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `GTEQ (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Pat_like (
            trans_pat_like (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_order_direction ((kind, body) : mt) : CST.order_direction =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_asc (
            trans_pat_asc (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_desc (
            trans_pat_desc (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_with_highlight ((kind, body) : mt) : CST.with_highlight =
  match body with
  | Children v ->
      trans_pat_high (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_order_null_direciton ((kind, body) : mt) : CST.order_null_direciton =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_nulls_pat_first (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_pat_nulls (Run.matcher_token v0),
                  trans_pat_first (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Pat_nulls_pat_last (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_pat_nulls (Run.matcher_token v0),
                  trans_pat_last (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_this ((kind, body) : mt) : CST.this =
  match body with
  | Children v ->
      trans_pat_this (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_dml_type ((kind, body) : mt) : CST.dml_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_insert (
            trans_pat_insert (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_update (
            trans_pat_update (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Pat_delete (
            trans_pat_delete (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Pat_unde (
            trans_pat_unde (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_for_type ((kind, body) : mt) : CST.for_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_update (
            trans_pat_update (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_ref (
            trans_pat_ref (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Pat_view (
            trans_pat_view (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_all_rows_clause ((kind, body) : mt) : CST.all_rows_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_all (Run.matcher_token v0),
            trans_pat_rows (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_in_type ((kind, body) : mt) : CST.in_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_all (
            trans_pat_all (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_email (
            trans_pat_email (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Pat_name (
            trans_pat_name (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Pat_phone (
            trans_pat_phone (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Pat_side (
            trans_pat_side (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_fields_type ((kind, body) : mt) : CST.fields_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_all (
            trans_pat_all (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_custom (
            trans_pat_custom (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Pat_stan (
            trans_pat_stan (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_void_type ((kind, body) : mt) : CST.void_type =
  match body with
  | Children v ->
      trans_pat_void (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_trigger_event ((kind, body) : mt) : CST.trigger_event =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_before_pat_insert (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_pat_before (Run.matcher_token v0),
                  trans_pat_insert (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Pat_before_pat_update (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_pat_before (Run.matcher_token v0),
                  trans_pat_update (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Pat_before_pat_delete (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_pat_before (Run.matcher_token v0),
                  trans_pat_delete (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Pat_after_pat_insert (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_pat_after (Run.matcher_token v0),
                  trans_pat_insert (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Pat_after_pat_update (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_pat_after (Run.matcher_token v0),
                  trans_pat_update (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `Pat_after_pat_delete (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_pat_after (Run.matcher_token v0),
                  trans_pat_delete (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (6, v) ->
          `Pat_after_pat_unde (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_pat_after (Run.matcher_token v0),
                  trans_pat_unde (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_set_comparison_operator ((kind, body) : mt) : CST.set_comparison_operator =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_in (
            trans_pat_in (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_not_pat_in (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_pat_not (Run.matcher_token v0),
                  trans_pat_in (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Pat_inclus (
            trans_pat_inclus (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Pat_exclus (
            trans_pat_exclus (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_with_pricebook_expression ((kind, body) : mt) : CST.with_pricebook_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_pric (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_string_literal (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_with_user_id_type ((kind, body) : mt) : CST.with_user_id_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_userid (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_string_literal (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_with_metadata_expression ((kind, body) : mt) : CST.with_metadata_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_meta (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_string_literal (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_date_literal_with_param ((kind, body) : mt) : CST.date_literal_with_param =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_tok_choice_pat_last_n_days (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_int_ (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_with_snippet_expression ((kind, body) : mt) : CST.with_snippet_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_snip (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3; v4] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_pat_target_len (Run.matcher_token v1),
                      Run.trans_token (Run.matcher_token v2),
                      trans_int_ (Run.matcher_token v3),
                      Run.trans_token (Run.matcher_token v4)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_date_literal ((kind, body) : mt) : CST.date_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_yest (
            trans_pat_yest (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_today (
            trans_pat_today (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Pat_tomo (
            trans_pat_tomo (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Pat_last_week (
            trans_pat_last_week (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Pat_this_week (
            trans_pat_this_week (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Pat_next_week (
            trans_pat_next_week (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Pat_last_month (
            trans_pat_last_month (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Pat_this_month (
            trans_pat_this_month (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Pat_next_month (
            trans_pat_next_month (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Pat_last_90_days (
            trans_pat_last_90_days (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Pat_next_90_days (
            trans_pat_next_90_days (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Pat_this_quar (
            trans_pat_this_quar (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Pat_last_quar (
            trans_pat_last_quar (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Pat_next_quar (
            trans_pat_next_quar (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Pat_this_year (
            trans_pat_this_year (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `Pat_last_year (
            trans_pat_last_year (Run.matcher_token v)
          )
      | Alt (16, v) ->
          `Pat_next_year (
            trans_pat_next_year (Run.matcher_token v)
          )
      | Alt (17, v) ->
          `Pat_this_fiscal_quar (
            trans_pat_this_fiscal_quar (Run.matcher_token v)
          )
      | Alt (18, v) ->
          `Pat_last_fiscal_quar (
            trans_pat_last_fiscal_quar (Run.matcher_token v)
          )
      | Alt (19, v) ->
          `Pat_next_fiscal_quar (
            trans_pat_next_fiscal_quar (Run.matcher_token v)
          )
      | Alt (20, v) ->
          `Pat_this_fiscal_year (
            trans_pat_this_fiscal_year (Run.matcher_token v)
          )
      | Alt (21, v) ->
          `Pat_last_fiscal_year (
            trans_pat_last_fiscal_year (Run.matcher_token v)
          )
      | Alt (22, v) ->
          `Pat_next_fiscal_year (
            trans_pat_next_fiscal_year (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_modifier ((kind, body) : mt) : CST.modifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_global (
            trans_pat_global (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_public (
            trans_pat_public (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Pat_test (
            trans_pat_test (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Pat_prot (
            trans_pat_prot (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Pat_over (
            trans_pat_over (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Pat_priv (
            trans_pat_priv (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Pat_virt (
            trans_pat_virt (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Pat_abst (
            trans_pat_abst (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Pat_static (
            trans_pat_static (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Pat_final (
            trans_pat_final (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Pat_tran (
            trans_pat_tran (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Pat_with_pat_shar (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_pat_with (Run.matcher_token v0),
                  trans_pat_shar (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (12, v) ->
          `Pat_with__pat_shar (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_pat_with_ (Run.matcher_token v0),
                  trans_pat_shar (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (13, v) ->
          `Pat_inhe_pat_shar (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_pat_inhe (Run.matcher_token v0),
                  trans_pat_shar (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_with_data_cat_filter_type ((kind, body) : mt) : CST.with_data_cat_filter_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_at (
            trans_pat_at (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_above (
            trans_pat_above (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Pat_below (
            trans_pat_below (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Pat_above_or_below (
            trans_pat_above_or_below (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_function_name ((kind, body) : mt) : CST.function_name =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_avg (
            trans_pat_avg (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_count (
            trans_pat_count (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Pat_count_dist (
            trans_pat_count_dist (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Pat_min (
            trans_pat_min (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Pat_max (
            trans_pat_max (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Pat_sum (
            trans_pat_sum (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Pat_grou (
            trans_pat_grou (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Pat_format (
            trans_pat_format (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Pat_conv (
            trans_pat_conv (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Pat_tola (
            trans_pat_tola (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Pat_cale_month (
            trans_pat_cale_month (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Pat_cale_quar (
            trans_pat_cale_quar (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Pat_cale_year (
            trans_pat_cale_year (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Pat_day_in_month (
            trans_pat_day_in_month (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Pat_day_in_week (
            trans_pat_day_in_week (Run.matcher_token v)
          )
      | Alt (15, v) ->
          `Pat_day_in_year (
            trans_pat_day_in_year (Run.matcher_token v)
          )
      | Alt (16, v) ->
          `Pat_day_only (
            trans_pat_day_only (Run.matcher_token v)
          )
      | Alt (17, v) ->
          `Pat_fiscal_month (
            trans_pat_fiscal_month (Run.matcher_token v)
          )
      | Alt (18, v) ->
          `Pat_fiscal_quar (
            trans_pat_fiscal_quar (Run.matcher_token v)
          )
      | Alt (19, v) ->
          `Pat_fiscal_year (
            trans_pat_fiscal_year (Run.matcher_token v)
          )
      | Alt (20, v) ->
          `Pat_hour_in_day (
            trans_pat_hour_in_day (Run.matcher_token v)
          )
      | Alt (21, v) ->
          `Pat_week_in_month (
            trans_pat_week_in_month (Run.matcher_token v)
          )
      | Alt (22, v) ->
          `Pat_week_in_year (
            trans_pat_week_in_year (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false



let trans_using_scope_type ((kind, body) : mt) : CST.using_scope_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_dele (
            trans_pat_dele (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_ever (
            trans_pat_ever (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Pat_mine (
            trans_pat_mine (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Pat_mine_and_my_groups (
            trans_pat_mine_and_my_groups (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Pat_my_terr (
            trans_pat_my_terr (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Pat_my_team_terr (
            trans_pat_my_team_terr (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Pat_team (
            trans_pat_team (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_using_clause ((kind, body) : mt) : CST.using_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_pat_using (Run.matcher_token v0),
            trans_pat_list (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_identifier (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_variable_declarator_id ((kind, body) : mt) : CST.variable_declarator_id =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_dimensions (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_continue_statement ((kind, body) : mt) : CST.continue_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_cont (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_identifier (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_dotted_identifier ((kind, body) : mt) : CST.dotted_identifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_break_statement ((kind, body) : mt) : CST.break_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_brk (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_identifier (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let rec trans_scoped_identifier ((kind, body) : mt) : CST.scoped_identifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Scoped_id (
                  trans_scoped_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_with_spell_correction_expression ((kind, body) : mt) : CST.with_spell_correction_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_spell_corr (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_boolean (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_literal ((kind, body) : mt) : CST.literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Int (
            trans_int_ (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Deci_floa_point_lit (
            trans_decimal_floating_point_literal (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Bool (
            trans_boolean (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Str_lit (
            trans_string_literal (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Null_lit (
            trans_null_literal (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_with_record_visibility_param ((kind, body) : mt) : CST.with_record_visibility_param =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_maxd_EQ_int (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_pat_maxd (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_int_ (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Pat_suppos_EQ_bool (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_pat_suppos (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_boolean (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Pat_suppos__EQ_bool (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_pat_suppos_ (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_boolean (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_update_clause ((kind, body) : mt) : CST.update_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_update (Run.matcher_token v0),
            trans_update_type (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_update_type (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_for_clause ((kind, body) : mt) : CST.for_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_for (Run.matcher_token v0),
            trans_for_type (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_for_type (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_in_clause ((kind, body) : mt) : CST.in_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_in (Run.matcher_token v0),
            trans_in_type (Run.matcher_token v1),
            trans_pat_fields (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_fields_expression ((kind, body) : mt) : CST.fields_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_pat_fields (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_fields_type (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_soql_literal ((kind, body) : mt) : CST.soql_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Int (
            trans_int_ (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Deci (
            trans_decimal (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Str_lit (
            trans_string_literal (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Date (
            trans_date (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Date_time (
            trans_date_time (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Bool (
            trans_boolean (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Date_lit (
            trans_date_literal (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Date_lit_with_param (
            trans_date_literal_with_param (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Curr_lit (
            trans_currency_literal (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Null_lit (
            trans_null_literal (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_with_data_cat_filter ((kind, body) : mt) : CST.with_data_cat_filter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            trans_with_data_cat_filter_type (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_id_rep_COMMA_id_RPAR (
                  (match v with
                  | Seq [v0; v1; v2; v3] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_identifier (Run.matcher_token v1),
                        Run.repeat
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_identifier (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v2
                        ,
                        Run.trans_token (Run.matcher_token v3)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_soql_using_clause ((kind, body) : mt) : CST.soql_using_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_using (Run.matcher_token v0),
            trans_pat_scope (Run.matcher_token v1),
            trans_using_scope_type (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_storage_identifier ((kind, body) : mt) : CST.storage_identifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Semg_meta_ellips (
            trans_semgrep_metavar_ellipsis (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Choice_id (
            (match v with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Dotted_id (
                  trans_dotted_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_field_identifier ((kind, body) : mt) : CST.field_identifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Dotted_id (
            trans_dotted_identifier (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_field_list ((kind, body) : mt) : CST.field_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Dotted_id (
                  trans_dotted_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Id (
                            trans_identifier (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Dotted_id (
                            trans_dotted_identifier (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_with_record_visibility_expression ((kind, body) : mt) : CST.with_record_visibility_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_pat_reco (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_with_record_visibility_param (Run.matcher_token v2),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_with_record_visibility_param (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_with_data_cat_expression ((kind, body) : mt) : CST.with_data_cat_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_pat_data (Run.matcher_token v0),
            trans_pat_cate (Run.matcher_token v1),
            trans_with_data_cat_filter (Run.matcher_token v2),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_pat_and (Run.matcher_token v0),
                      trans_with_data_cat_filter (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_storage_alias ((kind, body) : mt) : CST.storage_alias =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_storage_identifier (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_pat_as (Run.matcher_token v))
              v1
            ,
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_else_expression ((kind, body) : mt) : CST.else_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_else (Run.matcher_token v0),
            trans_field_list (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_when_expression ((kind, body) : mt) : CST.when_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_pat_when (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            trans_pat_then (Run.matcher_token v2),
            trans_field_list (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_soql_with_type ((kind, body) : mt) : CST.soql_with_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_secu_enfo (
            trans_pat_secu_enfo (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_user_mode (
            trans_pat_user_mode (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Pat_system_mode (
            trans_pat_system_mode (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `With_record_visi_exp (
            trans_with_record_visibility_expression (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `With_data_cat_exp (
            trans_with_data_cat_expression (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `With_user_id_type (
            trans_with_user_id_type (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_from_clause ((kind, body) : mt) : CST.from_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_from (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Stor_id (
                  trans_storage_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Stor_alias (
                  trans_storage_alias (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Stor_id (
                            trans_storage_identifier (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Stor_alias (
                            trans_storage_alias (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_type_of_clause ((kind, body) : mt) : CST.type_of_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_pat_typeof (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_when_expression (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v -> trans_else_expression (Run.matcher_token v))
              v3
            ,
            trans_pat_end (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_soql_with_clause ((kind, body) : mt) : CST.soql_with_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_with (Run.matcher_token v0),
            trans_soql_with_type (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_accessor_declaration ((kind, body) : mt) : CST.accessor_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Pat_get (
                  trans_pat_get (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Pat_set (
                  trans_pat_set (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v2 with
            | Alt (0, v) ->
                `Blk (
                  trans_block (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `SEMI (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_accessor_list ((kind, body) : mt) : CST.accessor_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat1
              (fun v -> trans_accessor_declaration (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_alias_expression ((kind, body) : mt) : CST.alias_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_value_expression (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_pat_as (Run.matcher_token v))
              v1
            ,
            trans_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_and_expression ((kind, body) : mt) : CST.and_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_condition_expression (Run.matcher_token v0),
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_pat_and (Run.matcher_token v0),
                      trans_condition_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_annotated_type ((kind, body) : mt) : CST.annotated_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.repeat1
              (fun v -> trans_annotation (Run.matcher_token v))
              v0
            ,
            trans_unannotated_type (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_annotation ((kind, body) : mt) : CST.annotation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Scoped_id (
                  trans_scoped_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v ->
                trans_annotation_argument_list (Run.matcher_token v)
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_annotation_argument_list ((kind, body) : mt) : CST.annotation_argument_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Elem_value (
                  trans_element_value (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Anno_key_value_rep_opt_COMMA_anno_key_value (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_annotation_key_value (Run.matcher_token v0),
                        Run.repeat
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.opt
                                    (fun v -> Run.trans_token (Run.matcher_token v))
                                    v0
                                  ,
                                  trans_annotation_key_value (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_annotation_key_value ((kind, body) : mt) : CST.annotation_key_value =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Id_EQ_elem_value (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_identifier (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_element_value (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_argument_list ((kind, body) : mt) : CST.argument_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      (match v0 with
                      | Alt (0, v) ->
                          `Semg_ellips (
                            trans_semgrep_ellipsis (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Semg_meta_ellips (
                            trans_semgrep_metavar_ellipsis (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Exp (
                            trans_expression (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                (match v1 with
                                | Alt (0, v) ->
                                    `Semg_ellips (
                                      trans_semgrep_ellipsis (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `Semg_meta_ellips (
                                      trans_semgrep_metavar_ellipsis (Run.matcher_token v)
                                    )
                                | Alt (2, v) ->
                                    `Exp (
                                      trans_expression (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_array_access ((kind, body) : mt) : CST.array_access =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_primary_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_array_creation_expression ((kind, body) : mt) : CST.array_creation_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_new (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Void_type (
                  trans_void_type (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Bool_type (
                  trans_boolean_type (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Scoped_type_id (
                  trans_scoped_type_identifier (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Gene_type (
                  trans_generic_type (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v2 with
            | Alt (0, v) ->
                `Rep1_dimens_expr_opt_dimens (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.repeat1
                          (fun v -> trans_dimensions_expr (Run.matcher_token v))
                          v0
                        ,
                        Run.opt
                          (fun v -> trans_dimensions (Run.matcher_token v))
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Dimens_array_init (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_dimensions (Run.matcher_token v0),
                        trans_array_initializer (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Array_init (
                  (match v with
                  | Seq [v0] ->
                      (trans_array_initializer (Run.matcher_token v0))
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_array_initializer ((kind, body) : mt) : CST.array_initializer =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      (match v0 with
                      | Alt (0, v) ->
                          `Exp (
                            trans_expression (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Array_init (
                            trans_array_initializer (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                      ,
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                (match v1 with
                                | Alt (0, v) ->
                                    `Exp (
                                      trans_expression (Run.matcher_token v)
                                    )
                                | Alt (1, v) ->
                                    `Array_init (
                                      trans_array_initializer (Run.matcher_token v)
                                    )
                                | _ -> assert false
                                )
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_array_type ((kind, body) : mt) : CST.array_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_unannotated_type (Run.matcher_token v0),
            trans_dimensions (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_assignment_expression ((kind, body) : mt) : CST.assignment_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Field_access (
                  trans_field_access (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Array_access (
                  trans_array_access (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            (match v1 with
            | Alt (0, v) ->
                `EQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `PLUSEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `DASHEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `STAREQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `SLASHEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `AMPEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `BAREQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `HATEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (8, v) ->
                `PERCEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (9, v) ->
                `LTLTEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (10, v) ->
                `GTGTEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (11, v) ->
                `GTGTGTEQ (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_binary_expression ((kind, body) : mt) : CST.binary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_GT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Exp_LT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Exp_GTEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Exp_LTEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Exp_EQEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `Exp_EQEQEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (6, v) ->
          `Exp_BANGEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `Exp_LTGT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (8, v) ->
          `Exp_BANGEQEQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (9, v) ->
          `Exp_AMPAMP_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (10, v) ->
          `Exp_BARBAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (11, v) ->
          `Exp_PLUS_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (12, v) ->
          `Exp_DASH_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (13, v) ->
          `Exp_STAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (14, v) ->
          `Exp_SLASH_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (15, v) ->
          `Exp_AMP_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (16, v) ->
          `Exp_BAR_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (17, v) ->
          `Exp_HAT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (18, v) ->
          `Exp_PERC_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (19, v) ->
          `Exp_LTLT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (20, v) ->
          `Exp_GTGT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (21, v) ->
          `Exp_GTGTGT_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_block ((kind, body) : mt) : CST.block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_statement (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_boolean_expression ((kind, body) : mt) : CST.boolean_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `And_exp (
            trans_and_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Or_exp (
            trans_or_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Not_exp (
            trans_not_expression (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Cond_exp (
            trans_condition_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bound_apex_expression ((kind, body) : mt) : CST.bound_apex_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_cast_expression ((kind, body) : mt) : CST.cast_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_ (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_expression (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_catch_clause ((kind, body) : mt) : CST.catch_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_pat_catch (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_catch_formal_parameter (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_block (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_catch_formal_parameter ((kind, body) : mt) : CST.catch_formal_parameter =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Opt_modifs_unan_type_var_decl_id (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.opt
                    (fun v -> trans_modifiers (Run.matcher_token v))
                    v0
                  ,
                  trans_unannotated_type (Run.matcher_token v1),
                  trans_variable_declarator_id (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_class_body ((kind, body) : mt) : CST.class_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Semg_ellips (
                      trans_semgrep_ellipsis (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Choice_field_decl (
                      (match v with
                      | Alt (0, v) ->
                          `Field_decl (
                            trans_field_declaration (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Meth_decl (
                            trans_method_declaration (Run.matcher_token v)
                          )
                      | Alt (2, v) ->
                          `Class_decl (
                            trans_class_declaration (Run.matcher_token v)
                          )
                      | Alt (3, v) ->
                          `Inte_decl (
                            trans_interface_declaration (Run.matcher_token v)
                          )
                      | Alt (4, v) ->
                          `Enum_decl (
                            trans_enum_declaration (Run.matcher_token v)
                          )
                      | Alt (5, v) ->
                          `Blk (
                            trans_block (Run.matcher_token v)
                          )
                      | Alt (6, v) ->
                          `Static_init (
                            trans_static_initializer (Run.matcher_token v)
                          )
                      | Alt (7, v) ->
                          `Cons_decl (
                            trans_constructor_declaration (Run.matcher_token v)
                          )
                      | Alt (8, v) ->
                          `SEMI (
                            Run.trans_token (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_class_declaration ((kind, body) : mt) : CST.class_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_class_header (Run.matcher_token v0),
            trans_class_body (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_class_header ((kind, body) : mt) : CST.class_header =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            trans_pat_class (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v -> trans_superclass (Run.matcher_token v))
              v4
            ,
            Run.opt
              (fun v -> trans_interfaces (Run.matcher_token v))
              v5
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_class_literal ((kind, body) : mt) : CST.class_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_unannotated_type (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_pat_class (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_comparison ((kind, body) : mt) : CST.comparison =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Value_comp (
            trans_value_comparison (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Set_comp (
            trans_set_comparison (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_comparison_expression ((kind, body) : mt) : CST.comparison_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_value_expression (Run.matcher_token v0),
            trans_comparison (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_condition_expression ((kind, body) : mt) : CST.condition_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Semg_meta (
            trans_semgrep_metavar (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Choice_LPAR_bool_exp_RPAR (
            (match v with
            | Alt (0, v) ->
                `LPAR_bool_exp_RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_boolean_expression (Run.matcher_token v1),
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Comp_exp (
                  trans_comparison_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_constant_declaration ((kind, body) : mt) : CST.constant_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            trans_unannotated_type (Run.matcher_token v1),
            trans_variable_declarator_list (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_constructor_body ((kind, body) : mt) : CST.constructor_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                trans_explicit_constructor_invocation (Run.matcher_token v)
              )
              v1
            ,
            Run.repeat
              (fun v -> trans_statement (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_constructor_declaration ((kind, body) : mt) : CST.constructor_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            trans_constructor_declarator (Run.matcher_token v1),
            trans_constructor_body (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_constructor_declarator ((kind, body) : mt) : CST.constructor_declarator =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v0
            ,
            trans_identifier (Run.matcher_token v1),
            trans_formal_parameters (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_declaration ((kind, body) : mt) : CST.declaration =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Class_decl (
            trans_class_declaration (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Trig_decl (
            trans_trigger_declaration (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Inte_decl (
            trans_interface_declaration (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Enum_decl (
            trans_enum_declaration (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_dimensions_expr ((kind, body) : mt) : CST.dimensions_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_dml_expression ((kind, body) : mt) : CST.dml_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Dml_type_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_dml_type (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Pat_upsert_exp_opt_unan_type (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_pat_upsert (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1),
                  Run.opt
                    (fun v -> trans_unannotated_type (Run.matcher_token v))
                    v2
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Pat_merge_exp_SPACE_exp (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  trans_pat_merge (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2),
                  trans_expression (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_do_statement ((kind, body) : mt) : CST.do_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_pat_do (Run.matcher_token v0),
            trans_statement (Run.matcher_token v1),
            trans_pat_while (Run.matcher_token v2),
            trans_parenthesized_expression (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_element_value ((kind, body) : mt) : CST.element_value =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp (
            trans_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Elem_value_array_init (
            trans_element_value_array_initializer (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Anno (
            trans_annotation (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_element_value_array_initializer ((kind, body) : mt) : CST.element_value_array_initializer =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_element_value (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_element_value (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_enhanced_for_statement ((kind, body) : mt) : CST.enhanced_for_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8] ->
          (
            trans_pat_for (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v2
            ,
            trans_unannotated_type (Run.matcher_token v3),
            trans_variable_declarator_id (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5),
            trans_expression (Run.matcher_token v6),
            Run.trans_token (Run.matcher_token v7),
            trans_statement (Run.matcher_token v8)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_enum_body ((kind, body) : mt) : CST.enum_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_enum_constant (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_enum_constant (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_enum_constant ((kind, body) : mt) : CST.enum_constant =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Opt_modifs_id (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.opt
                    (fun v -> trans_modifiers (Run.matcher_token v))
                    v0
                  ,
                  trans_identifier (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_enum_declaration ((kind, body) : mt) : CST.enum_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            trans_pat_enum (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_interfaces (Run.matcher_token v))
              v3
            ,
            trans_enum_body (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_explicit_constructor_invocation ((kind, body) : mt) : CST.explicit_constructor_invocation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Opt_type_args_choice_this (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.opt
                          (fun v -> trans_type_arguments (Run.matcher_token v))
                          v0
                        ,
                        (match v1 with
                        | Alt (0, v) ->
                            `This (
                              trans_this (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Super (
                              trans_super (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Choice_prim_exp_DOT_opt_type_args_super (
                  (match v with
                  | Seq [v0; v1; v2; v3] ->
                      (
                        (match v0 with
                        | Alt (0, v) ->
                            `Prim_exp (
                              trans_primary_expression (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.trans_token (Run.matcher_token v1),
                        Run.opt
                          (fun v -> trans_type_arguments (Run.matcher_token v))
                          v2
                        ,
                        trans_super (Run.matcher_token v3)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            trans_argument_list (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression ((kind, body) : mt) : CST.expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Assign_exp (
            trans_assignment_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Bin_exp (
            trans_binary_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Inst_exp (
            trans_instanceof_expression (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Tern_exp (
            trans_ternary_expression (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Update_exp (
            trans_update_expression (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Prim_exp (
            trans_primary_expression (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Un_exp (
            trans_unary_expression (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Cast_exp (
            trans_cast_expression (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Dml_exp (
            trans_dml_expression (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Switch_exp (
            trans_switch_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression_statement ((kind, body) : mt) : CST.expression_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_extends_interfaces ((kind, body) : mt) : CST.extends_interfaces =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_extends (Run.matcher_token v0),
            trans_type_list (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_field_access ((kind, body) : mt) : CST.field_access =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Prim_exp (
                  trans_primary_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Super (
                  trans_super (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_property_navigation (Run.matcher_token v0),
                      trans_super (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_property_navigation (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `This (
                  trans_this (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_field_declaration ((kind, body) : mt) : CST.field_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            trans_unannotated_type (Run.matcher_token v1),
            trans_variable_declarator_list (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `Acce_list (
                  trans_accessor_list (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `SEMI (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_finally_clause ((kind, body) : mt) : CST.finally_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_fina (Run.matcher_token v0),
            trans_block (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_find_clause ((kind, body) : mt) : CST.find_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_find (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Bound_apex_exp (
                  trans_bound_apex_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Term_sepa_start_term_term_sepa_end (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        trans_term_separator_start (Run.matcher_token v0),
                        trans_term (Run.matcher_token v1),
                        trans_term_separator_end (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_statement ((kind, body) : mt) : CST.for_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_pat_for (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Semg_ellips (
                  trans_semgrep_ellipsis (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Choice_local_var_decl_opt_exp_SEMI_opt_exp_rep_COMMA_exp (
                  (match v with
                  | Seq [v0; v1; v2; v3] ->
                      (
                        (match v0 with
                        | Alt (0, v) ->
                            `Local_var_decl (
                              trans_local_variable_declaration (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Opt_exp_rep_COMMA_exp_SEMI (
                              (match v with
                              | Seq [v0; v1] ->
                                  (
                                    Run.opt
                                      (fun v ->
                                        (match v with
                                        | Seq [v0; v1] ->
                                            (
                                              trans_expression (Run.matcher_token v0),
                                              Run.repeat
                                                (fun v ->
                                                  (match v with
                                                  | Seq [v0; v1] ->
                                                      (
                                                        Run.trans_token (Run.matcher_token v0),
                                                        trans_expression (Run.matcher_token v1)
                                                      )
                                                  | _ -> assert false
                                                  )
                                                )
                                                v1
                                            )
                                        | _ -> assert false
                                        )
                                      )
                                      v0
                                    ,
                                    Run.trans_token (Run.matcher_token v1)
                                  )
                              | _ -> assert false
                              )
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.opt
                          (fun v -> trans_expression (Run.matcher_token v))
                          v1
                        ,
                        Run.trans_token (Run.matcher_token v2),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  trans_expression (Run.matcher_token v0),
                                  Run.repeat
                                    (fun v ->
                                      (match v with
                                      | Seq [v0; v1] ->
                                          (
                                            Run.trans_token (Run.matcher_token v0),
                                            trans_expression (Run.matcher_token v1)
                                          )
                                      | _ -> assert false
                                      )
                                    )
                                    v1
                                )
                            | _ -> assert false
                            )
                          )
                          v3
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v3),
            trans_statement (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_formal_parameter ((kind, body) : mt) : CST.formal_parameter =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_modifs_unan_type_var_decl_id (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.opt
                    (fun v -> trans_modifiers (Run.matcher_token v))
                    v0
                  ,
                  trans_unannotated_type (Run.matcher_token v1),
                  trans_variable_declarator_id (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Semg_meta_ellips (
            trans_semgrep_metavar_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_formal_parameters ((kind, body) : mt) : CST.formal_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_formal_parameter (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_formal_parameter (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_expression ((kind, body) : mt) : CST.function_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_dist_LPAR_choice_field_id_COMMA_geo_loca_type_COMMA_str_lit_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
                (
                  trans_pat_dist (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  (match v2 with
                  | Alt (0, v) ->
                      `Field_id (
                        trans_field_identifier (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Bound_apex_exp (
                        trans_bound_apex_expression (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.trans_token (Run.matcher_token v3),
                  trans_geo_location_type (Run.matcher_token v4),
                  Run.trans_token (Run.matcher_token v5),
                  trans_string_literal (Run.matcher_token v6),
                  Run.trans_token (Run.matcher_token v7)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Func_name_LPAR_value_exp_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  trans_function_name (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_value_expression (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_generic_type ((kind, body) : mt) : CST.generic_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Scoped_type_id (
                  trans_scoped_type_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_type_arguments (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_geo_location_type ((kind, body) : mt) : CST.geo_location_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Field_id (
            trans_field_identifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Bound_apex_exp (
            trans_bound_apex_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Pat_geol_LPAR_deci_COMMA_deci_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5] ->
                (
                  trans_pat_geol (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_decimal (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3),
                  trans_decimal (Run.matcher_token v4),
                  Run.trans_token (Run.matcher_token v5)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_group_by_clause ((kind, body) : mt) : CST.group_by_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_pat_group (Run.matcher_token v0),
            trans_pat_by (Run.matcher_token v1),
            trans_group_by_expression (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_having_clause (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_group_by_expression ((kind, body) : mt) : CST.group_by_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_field_id_rep_COMMA_choice_field_id (
            (match v with
            | Seq [v0; v1] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Field_id (
                        trans_field_identifier (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Func_exp (
                        trans_function_expression (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            (match v1 with
                            | Alt (0, v) ->
                                `Field_id (
                                  trans_field_identifier (Run.matcher_token v)
                                )
                            | Alt (1, v) ->
                                `Func_exp (
                                  trans_function_expression (Run.matcher_token v)
                                )
                            | _ -> assert false
                            )
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Choice_pat_rollup_LPAR_field_id_rep_COMMA_field_id_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Pat_rollup (
                        trans_pat_rollup (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Pat_cube (
                        trans_pat_cube (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.trans_token (Run.matcher_token v1),
                  trans_field_identifier (Run.matcher_token v2),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_field_identifier (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                  ,
                  Run.trans_token (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_having_and_expression ((kind, body) : mt) : CST.having_and_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_having_condition_expression (Run.matcher_token v0),
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_pat_and (Run.matcher_token v0),
                      trans_having_condition_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_having_boolean_expression ((kind, body) : mt) : CST.having_boolean_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Having_and_exp (
            trans_having_and_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Having_or_exp (
            trans_having_or_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Having_not_exp (
            trans_having_not_expression (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Having_cond_exp (
            trans_having_condition_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_having_clause ((kind, body) : mt) : CST.having_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_having (Run.matcher_token v0),
            trans_having_boolean_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_having_comparison ((kind, body) : mt) : CST.having_comparison =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Having_value_comp (
            trans_having_value_comparison (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Having_set_comp (
            trans_having_set_comparison (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_having_comparison_expression ((kind, body) : mt) : CST.having_comparison_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_function_expression (Run.matcher_token v0),
            trans_having_comparison (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_having_condition_expression ((kind, body) : mt) : CST.having_condition_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LPAR_having_bool_exp_RPAR (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_having_boolean_expression (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Having_comp_exp (
            trans_having_comparison_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_having_not_expression ((kind, body) : mt) : CST.having_not_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_not (Run.matcher_token v0),
            trans_having_condition_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_having_or_expression ((kind, body) : mt) : CST.having_or_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_having_condition_expression (Run.matcher_token v0),
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_pat_or (Run.matcher_token v0),
                      trans_having_condition_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_having_set_comparison ((kind, body) : mt) : CST.having_set_comparison =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_set_comparison_operator (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `LPAR_choice_soql_lit_rep_COMMA_choice_soql_lit_RPAR (
                  (match v with
                  | Seq [v0; v1; v2; v3] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        (match v1 with
                        | Alt (0, v) ->
                            `Soql_lit (
                              trans_soql_literal (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Bound_apex_exp (
                              trans_bound_apex_expression (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.repeat
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  (match v1 with
                                  | Alt (0, v) ->
                                      `Soql_lit (
                                        trans_soql_literal (Run.matcher_token v)
                                      )
                                  | Alt (1, v) ->
                                      `Bound_apex_exp (
                                        trans_bound_apex_expression (Run.matcher_token v)
                                      )
                                  | _ -> assert false
                                  )
                                )
                            | _ -> assert false
                            )
                          )
                          v2
                        ,
                        Run.trans_token (Run.matcher_token v3)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Bound_apex_exp (
                  trans_bound_apex_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_having_value_comparison ((kind, body) : mt) : CST.having_value_comparison =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_value_comparison_operator (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Soql_lit (
                  trans_soql_literal (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Bound_apex_exp (
                  trans_bound_apex_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_if_statement ((kind, body) : mt) : CST.if_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_pat_if (Run.matcher_token v0),
            trans_parenthesized_expression (Run.matcher_token v1),
            trans_statement (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_pat_else (Run.matcher_token v0),
                      trans_statement (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_instanceof_expression ((kind, body) : mt) : CST.instanceof_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            trans_pat_inst (Run.matcher_token v1),
            trans_type_ (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_interface_body ((kind, body) : mt) : CST.interface_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Semg_ellips (
                      trans_semgrep_ellipsis (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Cst_decl (
                      trans_constant_declaration (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Enum_decl (
                      trans_enum_declaration (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `Meth_decl (
                      trans_method_declaration (Run.matcher_token v)
                    )
                | Alt (4, v) ->
                    `Class_decl (
                      trans_class_declaration (Run.matcher_token v)
                    )
                | Alt (5, v) ->
                    `Inte_decl (
                      trans_interface_declaration (Run.matcher_token v)
                    )
                | Alt (6, v) ->
                    `SEMI (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_interface_declaration ((kind, body) : mt) : CST.interface_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            trans_pat_inte (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v -> trans_extends_interfaces (Run.matcher_token v))
              v4
            ,
            trans_interface_body (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_interfaces ((kind, body) : mt) : CST.interfaces =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_imples (Run.matcher_token v0),
            trans_type_list (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_labeled_statement ((kind, body) : mt) : CST.labeled_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_statement (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_limit_clause ((kind, body) : mt) : CST.limit_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_limit (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Int (
                  trans_int_ (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Bound_apex_exp (
                  trans_bound_apex_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_local_variable_declaration ((kind, body) : mt) : CST.local_variable_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            trans_unannotated_type (Run.matcher_token v1),
            trans_variable_declarator_list (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_map_creation_expression ((kind, body) : mt) : CST.map_creation_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_new (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Void_type (
                  trans_void_type (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Bool_type (
                  trans_boolean_type (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Scoped_type_id (
                  trans_scoped_type_identifier (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Gene_type (
                  trans_generic_type (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_map_initializer (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_map_initializer ((kind, body) : mt) : CST.map_initializer =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_map_initializer_ (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_map_initializer_ (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_map_initializer_ ((kind, body) : mt) : CST.map_initializer_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_method_declaration ((kind, body) : mt) : CST.method_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            trans_method_header (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Blk (
                  trans_block (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `SEMI (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_method_declarator ((kind, body) : mt) : CST.method_declarator =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            trans_formal_parameters (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_dimensions (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_method_header ((kind, body) : mt) : CST.method_header =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_type_parameters (Run.matcher_token v0),
                      Run.repeat
                        (fun v -> trans_annotation (Run.matcher_token v))
                        v1
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_unannotated_type (Run.matcher_token v1),
            trans_method_declarator (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_method_invocation ((kind, body) : mt) : CST.method_invocation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Choice_prim_exp_prop_navi_opt_super_prop_navi_opt_type_args_id (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4] ->
                      (
                        (match v0 with
                        | Alt (0, v) ->
                            `Prim_exp (
                              trans_primary_expression (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Super (
                              trans_super (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        trans_property_navigation (Run.matcher_token v1),
                        Run.opt
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  trans_super (Run.matcher_token v0),
                                  trans_property_navigation (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v2
                        ,
                        Run.opt
                          (fun v -> trans_type_arguments (Run.matcher_token v))
                          v3
                        ,
                        trans_identifier (Run.matcher_token v4)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            trans_argument_list (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_modifiers ((kind, body) : mt) : CST.modifiers =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Alt (0, v) ->
              `Anno (
                trans_annotation (Run.matcher_token v)
              )
          | Alt (1, v) ->
              `Modi (
                trans_modifier (Run.matcher_token v)
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

and trans_not_expression ((kind, body) : mt) : CST.not_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_not (Run.matcher_token v0),
            trans_condition_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_object_creation_expression ((kind, body) : mt) : CST.object_creation_expression =
  match body with
  | Children v ->
      trans_unqualified_object_creation_expression (Run.matcher_token v)
  | Leaf _ -> assert false

and trans_offset_clause ((kind, body) : mt) : CST.offset_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_offset (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Int (
                  trans_int_ (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Bound_apex_exp (
                  trans_bound_apex_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_or_expression ((kind, body) : mt) : CST.or_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_condition_expression (Run.matcher_token v0),
            Run.repeat1
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_pat_or (Run.matcher_token v0),
                      trans_condition_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_order_by_clause ((kind, body) : mt) : CST.order_by_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_pat_order (Run.matcher_token v0),
            trans_pat_by (Run.matcher_token v1),
            trans_order_expression (Run.matcher_token v2),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_order_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_order_expression ((kind, body) : mt) : CST.order_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_value_expression (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_order_direction (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v -> trans_order_null_direciton (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_parenthesized_expression ((kind, body) : mt) : CST.parenthesized_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_primary_expression ((kind, body) : mt) : CST.primary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_lit (
            (match v with
            | Alt (0, v) ->
                `Lit (
                  trans_literal (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Class_lit (
                  trans_class_literal (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `This (
                  trans_this (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Paren_exp (
                  trans_parenthesized_expression (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `Obj_crea_exp (
                  trans_object_creation_expression (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `Field_access (
                  trans_field_access (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `Array_access (
                  trans_array_access (Run.matcher_token v)
                )
            | Alt (8, v) ->
                `Meth_invo (
                  trans_method_invocation (Run.matcher_token v)
                )
            | Alt (9, v) ->
                `Array_crea_exp (
                  trans_array_creation_expression (Run.matcher_token v)
                )
            | Alt (10, v) ->
                `Map_crea_exp (
                  trans_map_creation_expression (Run.matcher_token v)
                )
            | Alt (11, v) ->
                `Query_exp (
                  trans_query_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Semg_deep_exp (
            trans_semgrep_deep_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_query_expression ((kind, body) : mt) : CST.query_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Soql_query (
                  trans_soql_query (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Sosl_query (
                  trans_sosl_query (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_return_statement ((kind, body) : mt) : CST.return_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_ret (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_returning_clause ((kind, body) : mt) : CST.returning_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_retu (Run.matcher_token v0),
            trans_sobject_return (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_sobject_return (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_run_as_statement ((kind, body) : mt) : CST.run_as_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_e8c36c5 (Run.matcher_token v0),
            trans_parenthesized_expression (Run.matcher_token v1),
            trans_block (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_scoped_type_identifier ((kind, body) : mt) : CST.scoped_type_identifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Scoped_type_id (
                  trans_scoped_type_identifier (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Gene_type (
                  trans_generic_type (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            Run.repeat
              (fun v -> trans_annotation (Run.matcher_token v))
              v2
            ,
            trans_identifier (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_select_clause ((kind, body) : mt) : CST.select_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_select (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Count_exp (
                  trans_count_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Sele_exp_rep_COMMA_sele_exp (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_selectable_expression (Run.matcher_token v0),
                        Run.repeat
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_selectable_expression (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_selectable_expression ((kind, body) : mt) : CST.selectable_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Semg_meta_ellips (
            trans_semgrep_metavar_ellipsis (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Choice_value_exp (
            (match v with
            | Alt (0, v) ->
                `Value_exp (
                  trans_value_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Alias_exp (
                  trans_alias_expression (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Type_of_clause (
                  trans_type_of_clause (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Fields_exp (
                  trans_fields_expression (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Subq (
                  trans_subquery (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_selected_fields ((kind, body) : mt) : CST.selected_fields =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_selectable_expression (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_selectable_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_semgrep_deep_expression ((kind, body) : mt) : CST.semgrep_deep_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_set_comparison ((kind, body) : mt) : CST.set_comparison =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_set_comparison_operator (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Subq (
                  trans_subquery (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_choice_soql_lit_rep_COMMA_choice_soql_lit_RPAR (
                  (match v with
                  | Seq [v0; v1; v2; v3] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        (match v1 with
                        | Alt (0, v) ->
                            `Soql_lit (
                              trans_soql_literal (Run.matcher_token v)
                            )
                        | Alt (1, v) ->
                            `Bound_apex_exp (
                              trans_bound_apex_expression (Run.matcher_token v)
                            )
                        | _ -> assert false
                        )
                        ,
                        Run.repeat
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  (match v1 with
                                  | Alt (0, v) ->
                                      `Soql_lit (
                                        trans_soql_literal (Run.matcher_token v)
                                      )
                                  | Alt (1, v) ->
                                      `Bound_apex_exp (
                                        trans_bound_apex_expression (Run.matcher_token v)
                                      )
                                  | _ -> assert false
                                  )
                                )
                            | _ -> assert false
                            )
                          )
                          v2
                        ,
                        Run.trans_token (Run.matcher_token v3)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Bound_apex_exp (
                  trans_bound_apex_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_sobject_return ((kind, body) : mt) : CST.sobject_return =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_selected_fields (Run.matcher_token v1),
                      Run.opt
                        (fun v -> trans_using_clause (Run.matcher_token v))
                        v2
                      ,
                      Run.opt
                        (fun v -> trans_where_clause (Run.matcher_token v))
                        v3
                      ,
                      Run.opt
                        (fun v -> trans_order_by_clause (Run.matcher_token v))
                        v4
                      ,
                      Run.opt
                        (fun v -> trans_limit_clause (Run.matcher_token v))
                        v5
                      ,
                      Run.opt
                        (fun v -> trans_offset_clause (Run.matcher_token v))
                        v6
                      ,
                      Run.trans_token (Run.matcher_token v7)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_soql_query ((kind, body) : mt) : CST.soql_query =
  match body with
  | Children v ->
      (match v with
      | Seq [v0] ->
          (trans_soql_query_body (Run.matcher_token v0))
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_soql_query_body ((kind, body) : mt) : CST.soql_query_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8; v9; v10; v11] ->
          (
            trans_select_clause (Run.matcher_token v0),
            trans_from_clause (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_soql_using_clause (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v -> trans_where_clause (Run.matcher_token v))
              v3
            ,
            Run.opt
              (fun v -> trans_soql_with_clause (Run.matcher_token v))
              v4
            ,
            Run.opt
              (fun v -> trans_group_by_clause (Run.matcher_token v))
              v5
            ,
            Run.opt
              (fun v -> trans_order_by_clause (Run.matcher_token v))
              v6
            ,
            Run.opt
              (fun v -> trans_limit_clause (Run.matcher_token v))
              v7
            ,
            Run.opt
              (fun v -> trans_offset_clause (Run.matcher_token v))
              v8
            ,
            Run.opt
              (fun v -> trans_for_clause (Run.matcher_token v))
              v9
            ,
            Run.opt
              (fun v -> trans_update_clause (Run.matcher_token v))
              v10
            ,
            Run.opt
              (fun v -> trans_all_rows_clause (Run.matcher_token v))
              v11
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_sosl_query ((kind, body) : mt) : CST.sosl_query =
  match body with
  | Children v ->
      (match v with
      | Seq [v0] ->
          (trans_sosl_query_body (Run.matcher_token v0))
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_sosl_query_body ((kind, body) : mt) : CST.sosl_query_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            trans_find_clause (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_in_clause (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v ->
                Run.repeat
                  (fun v -> trans_returning_clause (Run.matcher_token v))
                  v
              )
              v2
            ,
            Run.opt
              (fun v ->
                Run.repeat
                  (fun v -> trans_sosl_with_clause (Run.matcher_token v))
                  v
              )
              v3
            ,
            Run.opt
              (fun v -> trans_limit_clause (Run.matcher_token v))
              v4
            ,
            Run.opt
              (fun v -> trans_offset_clause (Run.matcher_token v))
              v5
            ,
            Run.opt
              (fun v -> trans_update_clause (Run.matcher_token v))
              v6
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_sosl_with_clause ((kind, body) : mt) : CST.sosl_with_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_with (Run.matcher_token v0),
            trans_sosl_with_type (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_sosl_with_type ((kind, body) : mt) : CST.sosl_with_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `With_data_cat_exp (
            trans_with_data_cat_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `With_divi_exp (
            trans_with_division_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `With_high (
            trans_with_highlight (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `With_meta_exp (
            trans_with_metadata_expression (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `With_netw_exp (
            trans_with_network_expression (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `With_pric_exp (
            trans_with_pricebook_expression (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `With_snip_exp (
            trans_with_snippet_expression (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `With_spell_corr_exp (
            trans_with_spell_correction_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_statement ((kind, body) : mt) : CST.statement =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_decl (
            (match v with
            | Alt (0, v) ->
                `Decl (
                  trans_declaration (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Exp_stmt (
                  trans_expression_statement (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Labe_stmt (
                  trans_labeled_statement (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `If_stmt (
                  trans_if_statement (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `While_stmt (
                  trans_while_statement (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `For_stmt (
                  trans_for_statement (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `Enha_for_stmt (
                  trans_enhanced_for_statement (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `Blk (
                  trans_block (Run.matcher_token v)
                )
            | Alt (8, v) ->
                `SEMI (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (9, v) ->
                `Do_stmt (
                  trans_do_statement (Run.matcher_token v)
                )
            | Alt (10, v) ->
                `Brk_stmt (
                  trans_break_statement (Run.matcher_token v)
                )
            | Alt (11, v) ->
                `Cont_stmt (
                  trans_continue_statement (Run.matcher_token v)
                )
            | Alt (12, v) ->
                `Ret_stmt (
                  trans_return_statement (Run.matcher_token v)
                )
            | Alt (13, v) ->
                `Switch_exp (
                  trans_switch_expression (Run.matcher_token v)
                )
            | Alt (14, v) ->
                `Local_var_decl (
                  trans_local_variable_declaration (Run.matcher_token v)
                )
            | Alt (15, v) ->
                `Throw_stmt (
                  trans_throw_statement (Run.matcher_token v)
                )
            | Alt (16, v) ->
                `Try_stmt (
                  trans_try_statement (Run.matcher_token v)
                )
            | Alt (17, v) ->
                `Run_as_stmt (
                  trans_run_as_statement (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_static_initializer ((kind, body) : mt) : CST.static_initializer =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_static (Run.matcher_token v0),
            trans_block (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_subquery ((kind, body) : mt) : CST.subquery =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_soql_query_body (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_superclass ((kind, body) : mt) : CST.superclass =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_extends (Run.matcher_token v0),
            trans_type_ (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_block ((kind, body) : mt) : CST.switch_block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat1
              (fun v -> trans_switch_rule (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_expression ((kind, body) : mt) : CST.switch_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_pat_switch (Run.matcher_token v0),
            trans_pat_on (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            trans_switch_block (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_label ((kind, body) : mt) : CST.switch_label =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_when (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Opt_unan_type_id_rep_COMMA_opt_unan_type_id (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.opt
                          (fun v -> trans_unannotated_type (Run.matcher_token v))
                          v0
                        ,
                        trans_identifier (Run.matcher_token v1),
                        Run.repeat
                          (fun v ->
                            (match v with
                            | Seq [v0; v1; v2] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  Run.opt
                                    (fun v -> trans_unannotated_type (Run.matcher_token v))
                                    v1
                                  ,
                                  trans_identifier (Run.matcher_token v2)
                                )
                            | _ -> assert false
                            )
                          )
                          v2
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Exp_rep_COMMA_exp (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_expression (Run.matcher_token v0),
                        Run.repeat
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_expression (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | Alt (2, v) ->
                `Pat_else (
                  trans_pat_else (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_switch_rule ((kind, body) : mt) : CST.switch_rule =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Switch_label_blk (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_switch_label (Run.matcher_token v0),
                  trans_block (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_ternary_expression ((kind, body) : mt) : CST.ternary_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_throw_statement ((kind, body) : mt) : CST.throw_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_throw (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_trigger_body ((kind, body) : mt) : CST.trigger_body =
  match body with
  | Children v ->
      trans_block (Run.matcher_token v)
  | Leaf _ -> assert false

and trans_trigger_declaration ((kind, body) : mt) : CST.trigger_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7; v8] ->
          (
            trans_pat_trig (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            trans_pat_on (Run.matcher_token v2),
            trans_identifier (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4),
            trans_trigger_event (Run.matcher_token v5),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_trigger_event (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v6
            ,
            Run.trans_token (Run.matcher_token v7),
            trans_trigger_body (Run.matcher_token v8)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_try_statement ((kind, body) : mt) : CST.try_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_try (Run.matcher_token v0),
            trans_block (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Rep1_catch_clause (
                  Run.repeat1
                    (fun v -> trans_catch_clause (Run.matcher_token v))
                    v
                )
            | Alt (1, v) ->
                `Rep_catch_clause_fina_clause (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.repeat
                          (fun v -> trans_catch_clause (Run.matcher_token v))
                          v0
                        ,
                        trans_finally_clause (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_ ((kind, body) : mt) : CST.type_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Unan_type (
            trans_unannotated_type (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Anno_type (
            trans_annotated_type (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_arguments ((kind, body) : mt) : CST.type_arguments =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_type_ (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_type_ (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_bound ((kind, body) : mt) : CST.type_bound =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_extends (Run.matcher_token v0),
            trans_type_ (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_list ((kind, body) : mt) : CST.type_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_type_ (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_parameter ((kind, body) : mt) : CST.type_parameter =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Rep_anno_id_opt_type_bound (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  Run.repeat
                    (fun v -> trans_annotation (Run.matcher_token v))
                    v0
                  ,
                  trans_identifier (Run.matcher_token v1),
                  Run.opt
                    (fun v -> trans_type_bound (Run.matcher_token v))
                    v2
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_parameters ((kind, body) : mt) : CST.type_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_parameter (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_parameter (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unannotated_type ((kind, body) : mt) : CST.unannotated_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_void_type (
            (match v with
            | Alt (0, v) ->
                `Void_type (
                  trans_void_type (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Bool_type (
                  trans_boolean_type (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Scoped_type_id (
                  trans_scoped_type_identifier (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Gene_type (
                  trans_generic_type (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Array_type (
            trans_array_type (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unary_expression ((kind, body) : mt) : CST.unary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `PLUS_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `DASH_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `BANG_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `TILDE_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unqualified_object_creation_expression ((kind, body) : mt) : CST.unqualified_object_creation_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_pat_new (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_arguments (Run.matcher_token v))
              v1
            ,
            (match v2 with
            | Alt (0, v) ->
                `Void_type (
                  trans_void_type (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Bool_type (
                  trans_boolean_type (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Id (
                  trans_identifier (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Scoped_type_id (
                  trans_scoped_type_identifier (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Gene_type (
                  trans_generic_type (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_argument_list (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_class_body (Run.matcher_token v))
              v4
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_update_expression ((kind, body) : mt) : CST.update_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_PLUSPLUS (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Exp_DASHDASH (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_expression (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `PLUSPLUS_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `DASHDASH_exp (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_value_comparison ((kind, body) : mt) : CST.value_comparison =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_value_comparison_operator (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Soql_lit (
                  trans_soql_literal (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Bound_apex_exp (
                  trans_bound_apex_expression (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_value_expression ((kind, body) : mt) : CST.value_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Func_exp (
            trans_function_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Field_id (
            trans_field_identifier (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_variable_declarator ((kind, body) : mt) : CST.variable_declarator =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_variable_declarator_id (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      (match v1 with
                      | Alt (0, v) ->
                          `Exp (
                            trans_expression (Run.matcher_token v)
                          )
                      | Alt (1, v) ->
                          `Array_init (
                            trans_array_initializer (Run.matcher_token v)
                          )
                      | _ -> assert false
                      )
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_variable_declarator_list ((kind, body) : mt) : CST.variable_declarator_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_variable_declarator (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_variable_declarator (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_where_clause ((kind, body) : mt) : CST.where_clause =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_where (Run.matcher_token v0),
            trans_boolean_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_while_statement ((kind, body) : mt) : CST.while_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_while (Run.matcher_token v0),
            trans_parenthesized_expression (Run.matcher_token v1),
            trans_statement (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_with_division_expression ((kind, body) : mt) : CST.with_division_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_pat_divi (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Bound_apex_exp (
                  trans_bound_apex_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Str_lit (
                  trans_string_literal (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_with_network_expression ((kind, body) : mt) : CST.with_network_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_netw (Run.matcher_token v0),
            trans_comparison (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_partial_try ((kind, body) : mt) : CST.partial_try =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_try (Run.matcher_token v0),
            trans_block (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false





let trans_partial_finally ((kind, body) : mt) : CST.partial_finally =
  match body with
  | Children v ->
      trans_finally_clause (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_partial_catch ((kind, body) : mt) : CST.partial_catch =
  match body with
  | Children v ->
      trans_catch_clause (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_partial_if ((kind, body) : mt) : CST.partial_if =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_pat_if (Run.matcher_token v0),
            trans_parenthesized_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_full_method_header ((kind, body) : mt) : CST.full_method_header =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.opt
              (fun v -> trans_modifiers (Run.matcher_token v))
              v0
            ,
            trans_method_header (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_parser_output ((kind, body) : mt) : CST.parser_output =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Rep_stmt (
            Run.repeat
              (fun v -> trans_statement (Run.matcher_token v))
              v
          )
      | Alt (1, v) ->
          `Cons_decl (
            trans_constructor_declaration (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Exp (
            trans_expression (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Anno (
            trans_annotation (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Meth_decl (
            trans_method_declaration (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Local_var_decl (
            trans_local_variable_declaration (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Class_header (
            trans_class_header (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Full_meth_header (
            trans_full_method_header (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Part_if (
            trans_partial_if (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Part_try (
            trans_partial_try (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Part_catch (
            trans_partial_catch (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Part_fina (
            trans_partial_finally (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

(*
   Costly operation that translates a whole tree or subtree.

   The first pass translates it into a generic tree structure suitable
   to guess which node corresponds to each grammar rule.
   The second pass is a translation into a typed tree where each grammar
   node has its own type.

   This function is called:
   - once on the root of the program after removing extras
     (comments and other nodes that occur anywhere independently from
     the grammar);
   - once of each extra node, resulting in its own independent tree of type
     'extra'.
*)
let translate_tree src node trans_x =
  let matched_tree = Run.match_tree children_regexps src node in
  Option.map trans_x matched_tree


let translate_extra src (node : Tree_sitter_output_t.node) : CST.extra option =
  match node.type_ with
  | "line_comment" ->
      (match translate_tree src node trans_line_comment with
      | None -> None
      | Some x -> Some (`Line_comment (Run.get_loc node, x)))
  | "block_comment" ->
      (match translate_tree src node trans_block_comment with
      | None -> None
      | Some x -> Some (`Block_comment (Run.get_loc node, x)))
  | _ -> None

let translate_root src root_node =
  translate_tree src root_node trans_parser_output

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let opt_program, extras =
     Run.translate
       ~extras
       ~translate_root:(translate_root src)
       ~translate_extra:(translate_extra src)
       orig_root_node
  in
  Parsing_result.create src opt_program extras errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

