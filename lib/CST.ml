(* Generated by ocaml-tree-sitter. *)
(*
   apex grammar

   entrypoint: parser_output
*)

open! Sexplib.Conv
open Tree_sitter_run

type pat_snip = Token.t (* pattern [sS][nN][iI][pP][pP][eE][tT] *)

type pat_data = Token.t (* pattern [dD][aA][tT][aA] *)

type pat_first = Token.t (* pattern [fF][iI][rR][sS][tT] *)

type pat_suppos =
  Token.t (* pattern [sS][uU][pP][pP][oO][rR][tT][sS][dD][oO][mM][aA][iI][nN][sS] *)

type pat_view = Token.t (* pattern [vV][iI][eE][wW] *)

type pat_find = Token.t (* pattern [fF][iI][nN][dD] *)

type pat_suppos_ =
  Token.t (* pattern [sS][uU][pP][pP][oO][rR][tT][sS][dD][eE][lL][eE][gG][aA][tT][eE][sS] *)

type pat_final = Token.t (* pattern [fF][iI][nN][aA][lL] *)

type pat_my_team_terr =
  Token.t (* pattern [mM][yY][__][tT][eE][aA][mM][__][tT][eE][rR][rR][iI][tT][oO][rR][yY] *)

type currency_literal = Token.t (* pattern \w{3}\d+(\.\d+)? *)

type pat_virt = Token.t (* pattern [vV][iI][rR][tT][uU][aA][lL] *)

type pat_shar = Token.t (* pattern [sS][hH][aA][rR][iI][nN][gG] *)

type pat_in = Token.t (* pattern [iI][nN] *)

type pat_meta = Token.t (* pattern [mM][eE][tT][aA][dD][aA][tT][aA] *)

type pat_user_mode =
  Token.t (* pattern [uU][sS][eE][rR][__][mM][oO][dD][eE] *)

type pat_prot = Token.t (* pattern [pP][rR][oO][tT][eE][cC][tT][eE][dD] *)

type pat_next_fiscal_year =
  Token.t (* pattern [nN][eE][xX][tT][__][fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *)

type pat_tola = Token.t (* pattern [tT][oO][lL][aA][bB][eE][lL] *)

type block_comment_explicit = unit (* blank *)

type pat_offset = Token.t (* pattern [oO][fF][fF][sS][eE][tT] *)

type pat_today = Token.t (* pattern [tT][oO][dD][aA][yY] *)

type semgrep_metavar_ellipsis =
  Token.t (* pattern \$\.\.\.[A-Z_][A-Z_0-9]* *)

type pat_then = Token.t (* pattern [tT][hH][eE][nN] *)

type pat_above = Token.t (* pattern [aA][bB][oO][vV][eE] *)

type pat_insert = Token.t (* pattern [iI][nN][sS][eE][rR][tT] *)

type pat_merge = Token.t (* pattern [mM][eE][rR][gG][eE] *)

type pat_count_dist =
  Token.t (* pattern [cC][oO][uU][nN][tT][__][dD][iI][sS][tT][iI][nN][cC][tT] *)

type pat_nulls = Token.t (* pattern [nN][uU][lL][lL][sS] *)

type date =
  Token.t (* pattern [1-4][0-9]{3}-(?:0[1-9]|1[0-2])-(?:[0-2][1-9]|[1-2]0|3[0-1]) *)

type decimal_floating_point_literal = Token.t

type pat_last_month =
  Token.t (* pattern [lL][aA][sS][tT][__][mM][oO][nN][tT][hH] *)

type property_navigation = (Token.t (* "?" *) option * Token.t (* "." *))

type pat_cale_month =
  Token.t (* pattern [cC][aA][lL][eE][nN][dD][aA][rR][__][mM][oO][nN][tT][hH] *)

type pat_unde = Token.t (* pattern [uU][nN][dD][eE][lL][eE][tT][eE] *)

type pat_inclus = Token.t (* pattern [iI][nN][cC][lL][uU][dD][eE][sS] *)

type pat_side = Token.t (* pattern [sS][iI][dD][eE][bB][aA][rR] *)

type pat_dele = Token.t (* pattern [dD][eE][lL][eE][gG][aA][tT][eE][dD] *)

type pat_fields = Token.t (* pattern [fF][iI][eE][lL][dD][sS] *)

type pat_fiscal_month =
  Token.t (* pattern [fF][iI][sS][cC][aA][lL][__][mM][oO][nN][tT][hH] *)

type pat_when = Token.t (* pattern [wW][hH][eE][nN] *)

type pat_like = Token.t (* pattern [lL][iI][kK][eE] *)

type pat_avg = Token.t (* pattern [aA][vV][gG] *)

type pat_scope = Token.t (* pattern [sS][cC][oO][pP][eE] *)

type pat_sum = Token.t (* pattern [sS][uU][mM] *)

type pat_target_len =
  Token.t (* pattern [tT][aA][rR][gG][eE][tT][__][lL][eE][nN][gG][tT][hH] *)

type pat_try = Token.t (* pattern [tT][rR][yY] *)

type pat_inst =
  Token.t (* pattern [iI][nN][sS][tT][aA][nN][cC][eE][oO][fF] *)

type pat_mine = Token.t (* pattern [mM][iI][nN][eE] *)

type date_time =
  Token.t (* pattern [1-4][0-9]{3}-(?:0[1-9]|1[0-2])-(?:[0-2][1-9]|[1-2]0|3[0-1])T([0-1]\d|2[0-3]):[0-5]\d:[0-5]\d(?:\.\d\d?\d?)?(?:Z|[+-][0-1]\d:[0-5]\d) *)

type pat_while = Token.t (* pattern [wW][hH][iI][lL][eE] *)

type pat_ret = Token.t (* pattern [rR][eE][tT][uU][rR][nN] *)

type pat_with = Token.t (* pattern [wW][iI][tT][hH] *)

type pat_where = Token.t (* pattern [wW][hH][eE][rR][eE] *)

type pat_this_month =
  Token.t (* pattern [tT][hH][iI][sS][__][mM][oO][nN][tT][hH] *)

type pat_high = Token.t (* pattern [hH][iI][gG][hH][lL][iI][gG][hH][tT] *)

type pat_tran = Token.t (* pattern [tT][rR][aA][nN][sS][iI][eE][nN][tT] *)

type pat_as = Token.t (* pattern [aA][sS] *)

type pat_next_90_days =
  Token.t (* pattern [nN][eE][xX][tT][__][99][00][__][dD][aA][yY][sS] *)

type pat_super = Token.t (* pattern [sS][uU][pP][eE][rR] *)

type pat_on = Token.t (* pattern [oO][nN] *)

type pat_min = Token.t (* pattern [mM][iI][nN] *)

type pat_mine_and_my_groups =
  Token.t (* pattern [mM][iI][nN][eE][__][aA][nN][dD][__][mM][yY][__][gG][rR][oO][uU][pP][sS] *)

type pat_list = Token.t (* pattern [lL][iI][sS][tT][vV][iI][eE][wW] *)

type string_literal =
  Token.t (* pattern "'(\\\\[nNrRtTbBfFuU\"'_%\\\\]|[^\\\\'])*'" *)

type pat_not = Token.t (* pattern [nN][oO][tT] *)

type pat_test =
  Token.t (* pattern [tT][eE][sS][tT][mM][eE][tT][hH][oO][dD] *)

type pat_typeof = Token.t (* pattern [tT][yY][pP][eE][oO][fF] *)

type pat_desc = Token.t (* pattern [dD][eE][sS][cC] *)

type pat_day_only = Token.t (* pattern [dD][aA][yY][__][oO][nN][lL][yY] *)

type pat_spell_corr =
  Token.t (* pattern [sS][pP][eE][lL][lL][__][cC][oO][rR][rR][eE][cC][tT][iI][oO][nN] *)

type pat_ref = Token.t (* pattern [rR][eE][fF][eE][rR][eE][nN][cC][eE] *)

type pat_public = Token.t (* pattern [pP][uU][bB][lL][iI][cC] *)

type pat_last = Token.t (* pattern [lL][aA][sS][tT] *)

type pat_upsert = Token.t (* pattern [uU][pP][sS][eE][rR][tT] *)

type pat_void = Token.t (* pattern [vV][oO][iI][dD] *)

type pat_netw = Token.t (* pattern [nN][eE][tT][wW][oO][rR][kK] *)

type pat_below = Token.t (* pattern [bB][eE][lL][oO][wW] *)

type line_comment_explicit = unit (* blank *)

type apex_identifier_ = Token.t (* pattern [\p{L}_$][\p{L}\p{Nd}_$]* *)

type pat_imples =
  Token.t (* pattern [iI][mM][pP][lL][eE][mM][eE][nN][tT][sS] *)

type pat_stan = Token.t (* pattern [sS][tT][aA][nN][dD][aA][rR][dD] *)

type pat_or = Token.t (* pattern [oO][rR] *)

type pat_cate = Token.t (* pattern [cC][aA][tT][eE][gG][oO][rR][yY] *)

type pat_before = Token.t (* pattern [bB][eE][fF][oO][rR][eE] *)

type pat_email = Token.t (* pattern [eE][mM][aA][iI][lL] *)

type pat_if = Token.t (* pattern [iI][fF] *)

type pat_rows = Token.t (* pattern [rR][oO][wW][sS] *)

type pat_else = Token.t (* pattern [eE][lL][sS][eE] *)

type pat_week_in_year =
  Token.t (* pattern [wW][eE][eE][kK][__][iI][nN][__][yY][eE][aA][rR] *)

type pat_limit = Token.t (* pattern [lL][iI][mM][iI][tT] *)

type pat_next_month =
  Token.t (* pattern [nN][eE][xX][tT][__][mM][oO][nN][tT][hH] *)

type pat_trac = Token.t (* pattern [tT][rR][aA][cC][kK][iI][nN][gG] *)

type block_comment = Token.t

type pat_dist = Token.t (* pattern [dD][iI][sS][tT][aA][nN][cC][eE] *)

type pat_rollup = Token.t (* pattern [rR][oO][lL][lL][uU][pP] *)

type pat_inte = Token.t (* pattern [iI][nN][tT][eE][rR][fF][aA][cC][eE] *)

type pat_set = Token.t (* pattern [sS][eE][tT] *)

type decimal = Token.t (* pattern -?\d+(\.\d+)? *)

type pat_last_fiscal_quar =
  Token.t (* pattern [lL][aA][sS][tT][__][fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *)

type pat_for = Token.t (* pattern [fF][oO][rR] *)

type pat_pric =
  Token.t (* pattern [pP][rR][iI][cC][eE][bB][oO][oO][kK][iI][dD] *)

type pat_last_fiscal_year =
  Token.t (* pattern [lL][aA][sS][tT][__][fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *)

type pat_this_quar =
  Token.t (* pattern [tT][hH][iI][sS][__][qQ][uU][aA][rR][tT][eE][rR] *)

type pat_at = Token.t (* pattern [aA][tT] *)

type pat_static = Token.t (* pattern [sS][tT][aA][tT][iI][cC] *)

type pat_fiscal_quar =
  Token.t (* pattern [fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *)

type pat_tomo = Token.t (* pattern [tT][oO][mM][oO][rR][rR][oO][wW] *)

type pat_geol =
  Token.t (* pattern [gG][eE][oO][lL][oO][cC][aA][tT][iI][oO][nN] *)

type pat_day_in_week =
  Token.t (* pattern [dD][aA][yY][__][iI][nN][__][wW][eE][eE][kK] *)

type pat_last_week =
  Token.t (* pattern [lL][aA][sS][tT][__][wW][eE][eE][kK] *)

type pat_divi = Token.t (* pattern [dD][iI][vV][iI][sS][iI][oO][nN] *)

type pat_abst = Token.t (* pattern [aA][bB][sS][tT][rR][aA][cC][tT] *)

type pat_custom = Token.t (* pattern [cC][uU][sS][tT][oO][mM] *)

type pat_userid = Token.t (* pattern [uU][sS][eE][rR][iI][dD] *)

type pat_over = Token.t (* pattern [oO][vV][eE][rR][rR][iI][dD][eE] *)

type pat_fina = Token.t (* pattern [fF][iI][nN][aA][lL][lL][yY] *)

type pat_trig = Token.t (* pattern [tT][rR][iI][gG][gG][eE][rR] *)

type pat_cale_quar =
  Token.t (* pattern [cC][aA][lL][eE][nN][dD][aA][rR][__][qQ][uU][aA][rR][tT][eE][rR] *)

type pat_this_week =
  Token.t (* pattern [tT][hH][iI][sS][__][wW][eE][eE][kK] *)

type pat_throw = Token.t (* pattern [tT][hH][rR][oO][wW] *)

type pat_ever =
  Token.t (* pattern [eE][vV][eE][rR][yY][tT][hH][iI][nN][gG] *)

type pat_cube = Token.t (* pattern [cC][uU][bB][eE] *)

type pat_hour_in_day =
  Token.t (* pattern [hH][oO][uU][rR][__][iI][nN][__][dD][aA][yY] *)

type pat_day_in_month =
  Token.t (* pattern [dD][aA][yY][__][iI][nN][__][mM][oO][nN][tT][hH] *)

type pat_last_90_days =
  Token.t (* pattern [lL][aA][sS][tT][__][99][00][__][dD][aA][yY][sS] *)

type dimensions =
  (Token.t (* "[" *) * Token.t (* "]" *)) list (* one or more *)

type pat_cale_year =
  Token.t (* pattern [cC][aA][lL][eE][nN][dD][aA][rR][__][yY][eE][aA][rR] *)

type pat_last_year =
  Token.t (* pattern [lL][aA][sS][tT][__][yY][eE][aA][rR] *)

type pat_end = Token.t (* pattern [eE][nN][dD] *)

type pat_format = Token.t (* pattern [fF][oO][rR][mM][aA][tT] *)

type pat_switch = Token.t (* pattern [sS][wW][iI][tT][cC][hH] *)

type pat_priv = Token.t (* pattern [pP][rR][iI][vV][aA][tT][eE] *)

type pat_count = Token.t (* pattern [cC][oO][uU][nN][tT] *)

type pat_this_fiscal_quar =
  Token.t (* pattern [tT][hH][iI][sS][__][fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *)

type term = Token.t (* pattern "(\\\\\\'|[^'])+" *)

type pat_after = Token.t (* pattern [aA][fF][tT][eE][rR] *)

type pat_next_year =
  Token.t (* pattern [nN][eE][xX][tT][__][yY][eE][aA][rR] *)

type pat_extends = Token.t (* pattern [eE][xX][tT][eE][nN][dD][sS] *)

type pat_update = Token.t (* pattern [uU][pP][dD][aA][tT][eE] *)

type pat_this_year =
  Token.t (* pattern [tT][hH][iI][sS][__][yY][eE][aA][rR] *)

type pat_view_ = Token.t (* pattern [vV][iI][eE][wW][sS][tT][aA][tT] *)

type pat_fiscal_year =
  Token.t (* pattern [fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *)

type pat_my_terr =
  Token.t (* pattern [mM][yY][__][tT][eE][rR][rR][iI][tT][oO][rR][yY] *)

type tok_choice_pat_last_n_days = Token.t

type pat_do = Token.t (* pattern [dD][oO] *)

type pat_true = Token.t (* pattern [tT][rR][uU][eE] *)

type pat_by = Token.t (* pattern [bB][yY] *)

type pat_above_or_below =
  Token.t (* pattern [aA][bB][oO][vV][eE][__][oO][rR][__][bB][eE][lL][oO][wW] *)

type pat_last_quar =
  Token.t (* pattern [lL][aA][sS][tT][__][qQ][uU][aA][rR][tT][eE][rR] *)

type pat_from = Token.t (* pattern [fF][rR][oO][mM] *)

type pat_team = Token.t (* pattern [tT][eE][aA][mM] *)

type pat_and = Token.t (* pattern [aA][nN][dD] *)

type pat_phone = Token.t (* pattern [pP][hH][oO][nN][eE] *)

type pat_this = Token.t (* pattern [tT][hH][iI][sS] *)

type pat_week_in_month =
  Token.t (* pattern [wW][eE][eE][kK][__][iI][nN][__][mM][oO][nN][tT][hH] *)

type pat_next_week =
  Token.t (* pattern [nN][eE][xX][tT][__][wW][eE][eE][kK] *)

type pat_having = Token.t (* pattern [hH][aA][vV][iI][nN][gG] *)

type pat_next_quar =
  Token.t (* pattern [nN][eE][xX][tT][__][qQ][uU][aA][rR][tT][eE][rR] *)

type pat_next_fiscal_quar =
  Token.t (* pattern [nN][eE][xX][tT][__][fF][iI][sS][cC][aA][lL][__][qQ][uU][aA][rR][tT][eE][rR] *)

type pat_asc = Token.t (* pattern [aA][sS][cC] *)

type pat_null = Token.t (* pattern [nN][uU][lL][lL] *)

type pat_global = Token.t (* pattern [gG][lL][oO][bB][aA][lL] *)

type pat_max = Token.t (* pattern [mM][aA][xX] *)

type pat_all = Token.t (* pattern [aA][lL][lL] *)

type pat_reco =
  Token.t (* pattern [rR][eE][cC][oO][rR][dD][vV][iI][sS][iI][bB][iI][lL][iI][tT][yY][cC][oO][nN][tT][eE][xX][tT] *)

type pat_cont = Token.t (* pattern [cC][oO][nN][tT][iI][nN][uU][eE] *)

type pat_get = Token.t (* pattern [gG][eE][tT] *)

type pat_select = Token.t (* pattern [sS][eE][lL][eE][cC][tT] *)

type pat_conv =
  Token.t (* pattern [cC][oO][nN][vV][eE][rR][tT][cC][uU][rR][rR][eE][nN][cC][yY] *)

type pat_inhe = Token.t (* pattern [iI][nN][hH][eE][rR][iI][tT][eE][dD] *)

type pat_maxd =
  Token.t (* pattern [mM][aA][xX][dD][eE][sS][cC][rR][iI][pP][tT][oO][rR][pP][eE][rR][rR][eE][cC][oO][rR][dD] *)

type pat_name = Token.t (* pattern [nN][aA][mM][eE] *)

type pat_catch = Token.t (* pattern [cC][aA][tT][cC][hH] *)

type semgrep_metavar = Token.t (* pattern \$[A-Z_][A-Z_0-9]* *)

type pat_retu = Token.t (* pattern [rR][eE][tT][uU][rR][nN][iI][nN][gG] *)

type pat_system_mode =
  Token.t (* pattern [sS][yY][sS][tT][eE][mM][__][mM][oO][dD][eE] *)

type pat_using = Token.t (* pattern [uU][sS][iI][nN][gG] *)

type pat_class = Token.t (* pattern [cC][lL][aA][sS][sS] *)

type pat_e8c36c5 =
  Token.t (* pattern [sS][yY][sS][tT][eE][mM][..][rR][uU][nN][aA][sS] *)

type pat_exclus = Token.t (* pattern [eE][xX][cC][lL][uU][dD][eE][sS] *)

type pat_order = Token.t (* pattern [oO][rR][dD][eE][rR] *)

type pat_yest = Token.t (* pattern [yY][eE][sS][tT][eE][rR][dD][aA][yY] *)

type pat_false = Token.t (* pattern [fF][aA][lL][sS][eE] *)

type pat_grou = Token.t (* pattern [gG][rR][oO][uU][pP][iI][nN][gG] *)

type pat_enum = Token.t (* pattern [eE][nN][uU][mM] *)

type pat_new = Token.t (* pattern [nN][eE][wW] *)

type pat_this_fiscal_year =
  Token.t (* pattern [tT][hH][iI][sS][__][fF][iI][sS][cC][aA][lL][__][yY][eE][aA][rR] *)

type pat_group = Token.t (* pattern [gG][rR][oO][uU][pP] *)

type int_ = Token.t

type pat_with_ = Token.t (* pattern [wW][iI][tT][hH][oO][uU][tT] *)

type pat_secu_enfo =
  Token.t (* pattern [sS][eE][cC][uU][rR][iI][tT][yY][__][eE][nN][fF][oO][rR][cC][eE][dD] *)

type pat_brk = Token.t (* pattern [bB][rR][eE][aA][kK] *)

type pat_day_in_year =
  Token.t (* pattern [dD][aA][yY][__][iI][nN][__][yY][eE][aA][rR] *)

type line_comment = Token.t

type pat_delete = Token.t (* pattern [dD][eE][lL][eE][tT][eE] *)

type value_comparison_operator = [
    `EQ of Token.t (* "=" *)
  | `BANGEQ of Token.t (* "!=" *)
  | `LTGT of Token.t (* "<>" *)
  | `LT of Token.t (* "<" *)
  | `LTEQ of Token.t (* "<=" *)
  | `GT of Token.t (* ">" *)
  | `GTEQ of Token.t (* ">=" *)
  | `Pat_like of pat_like
]

type with_highlight = pat_high

type super = pat_super

type order_null_direciton = [
    `Pat_nulls_pat_first of (pat_nulls * pat_first)
  | `Pat_nulls_pat_last of (pat_nulls * pat_last)
]

type void_type = pat_void

type count_expression = (pat_count * Token.t (* "(" *) * Token.t (* ")" *))

type for_type = [
    `Pat_update of pat_update
  | `Pat_ref of pat_ref
  | `Pat_view of pat_view
]

type update_type = [ `Pat_trac of pat_trac | `Pat_view_ of pat_view_ ]

type with_data_cat_filter_type = [
    `Pat_at of pat_at
  | `Pat_above of pat_above
  | `Pat_below of pat_below
  | `Pat_above_or_below of pat_above_or_below
]

type using_scope_type = [
    `Pat_dele of pat_dele
  | `Pat_ever of pat_ever
  | `Pat_mine of pat_mine
  | `Pat_mine_and_my_groups of pat_mine_and_my_groups
  | `Pat_my_terr of pat_my_terr
  | `Pat_my_team_terr of pat_my_team_terr
  | `Pat_team of pat_team
]

type this = pat_this

type order_direction = [ `Pat_asc of pat_asc | `Pat_desc of pat_desc ]

type null_literal = pat_null

type all_rows_clause = (pat_all * pat_rows)

type fields_type = [
    `Pat_all of pat_all
  | `Pat_custom of pat_custom
  | `Pat_stan of pat_stan
]

type in_type = [
    `Pat_all of pat_all
  | `Pat_email of pat_email
  | `Pat_name of pat_name
  | `Pat_phone of pat_phone
  | `Pat_side of pat_side
]

type identifier = [
    `Semg_meta of semgrep_metavar (*tok*)
  | `Apex_id_ of apex_identifier_ (*tok*)
]

type set_comparison_operator = [
    `Pat_in of pat_in
  | `Pat_not_pat_in of (pat_not * pat_in)
  | `Pat_inclus of pat_inclus
  | `Pat_exclus of pat_exclus
]

type boolean = [ `Pat_true of pat_true | `Pat_false of pat_false ]

type date_literal = [
    `Pat_yest of pat_yest
  | `Pat_today of pat_today
  | `Pat_tomo of pat_tomo
  | `Pat_last_week of pat_last_week
  | `Pat_this_week of pat_this_week
  | `Pat_next_week of pat_next_week
  | `Pat_last_month of pat_last_month
  | `Pat_this_month of pat_this_month
  | `Pat_next_month of pat_next_month
  | `Pat_last_90_days of pat_last_90_days
  | `Pat_next_90_days of pat_next_90_days
  | `Pat_this_quar of pat_this_quar
  | `Pat_last_quar of pat_last_quar
  | `Pat_next_quar of pat_next_quar
  | `Pat_this_year of pat_this_year
  | `Pat_last_year of pat_last_year
  | `Pat_next_year of pat_next_year
  | `Pat_this_fiscal_quar of pat_this_fiscal_quar
  | `Pat_last_fiscal_quar of pat_last_fiscal_quar
  | `Pat_next_fiscal_quar of pat_next_fiscal_quar
  | `Pat_this_fiscal_year of pat_this_fiscal_year
  | `Pat_last_fiscal_year of pat_last_fiscal_year
  | `Pat_next_fiscal_year of pat_next_fiscal_year
]

type modifier = [
    `Pat_global of pat_global
  | `Pat_public of pat_public
  | `Pat_test of pat_test
  | `Pat_prot of pat_prot
  | `Pat_over of pat_over
  | `Pat_priv of pat_priv
  | `Pat_virt of pat_virt
  | `Pat_abst of pat_abst
  | `Pat_static of pat_static
  | `Pat_final of pat_final
  | `Pat_tran of pat_tran
  | `Pat_with_pat_shar of (pat_with * pat_shar)
  | `Pat_with__pat_shar of (pat_with_ * pat_shar)
  | `Pat_inhe_pat_shar of (pat_inhe * pat_shar)
]

type function_name = [
    `Pat_avg of pat_avg
  | `Pat_count of pat_count
  | `Pat_count_dist of pat_count_dist
  | `Pat_min of pat_min
  | `Pat_max of pat_max
  | `Pat_sum of pat_sum
  | `Pat_grou of pat_grou
  | `Pat_format of pat_format
  | `Pat_conv of pat_conv
  | `Pat_tola of pat_tola
  | `Pat_cale_month of pat_cale_month
  | `Pat_cale_quar of pat_cale_quar
  | `Pat_cale_year of pat_cale_year
  | `Pat_day_in_month of pat_day_in_month
  | `Pat_day_in_week of pat_day_in_week
  | `Pat_day_in_year of pat_day_in_year
  | `Pat_day_only of pat_day_only
  | `Pat_fiscal_month of pat_fiscal_month
  | `Pat_fiscal_quar of pat_fiscal_quar
  | `Pat_fiscal_year of pat_fiscal_year
  | `Pat_hour_in_day of pat_hour_in_day
  | `Pat_week_in_month of pat_week_in_month
  | `Pat_week_in_year of pat_week_in_year
]

type trigger_event = [
    `Pat_before_pat_insert of (pat_before * pat_insert)
  | `Pat_before_pat_update of (pat_before * pat_update)
  | `Pat_before_pat_delete of (pat_before * pat_delete)
  | `Pat_after_pat_insert of (pat_after * pat_insert)
  | `Pat_after_pat_update of (pat_after * pat_update)
  | `Pat_after_pat_delete of (pat_after * pat_delete)
  | `Pat_after_pat_unde of (pat_after * pat_unde)
]

type dml_type = [
    `Pat_insert of pat_insert
  | `Pat_update of pat_update
  | `Pat_delete of pat_delete
  | `Pat_unde of pat_unde
]

type for_clause = (
    pat_for
  * for_type
  * (Token.t (* "," *) * for_type) list (* zero or more *)
)

type update_clause = (
    pat_update
  * update_type
  * (Token.t (* "," *) * update_type) list (* zero or more *)
)

type soql_using_clause = (pat_using * pat_scope * using_scope_type)

type fields_expression = (
    pat_fields * Token.t (* "(" *) * fields_type * Token.t (* ")" *)
)

type in_clause = (pat_in * in_type * pat_fields)

type using_clause = (pat_using * pat_list * Token.t (* "=" *) * identifier)

type variable_declarator_id = (identifier * dimensions option)

type break_statement = (pat_brk * identifier option * Token.t (* ";" *))

type continue_statement = (pat_cont * identifier option * Token.t (* ";" *))

type name = [
    `Id of identifier
  | `Scoped_id of (name * Token.t (* "." *) * identifier)
]

type inferred_parameters = (
    Token.t (* "(" *)
  * identifier
  * (Token.t (* "," *) * identifier) list (* zero or more *)
  * Token.t (* ")" *)
)

type literal = [
    `Int of int_ (*tok*)
  | `Deci_floa_point_lit of decimal_floating_point_literal (*tok*)
  | `Bool of boolean
  | `Str_lit of string_literal (*tok*)
  | `Null_lit of null_literal
]

type with_record_visibility_param = [
    `Pat_maxd_EQ_int of (pat_maxd * Token.t (* "=" *) * int_ (*tok*))
  | `Pat_suppos_EQ_bool of (pat_suppos * Token.t (* "=" *) * boolean)
  | `Pat_suppos__EQ_bool of (pat_suppos_ * Token.t (* "=" *) * boolean)
]

type soql_literal = [
    `Int of int_ (*tok*)
  | `Deci of decimal (*tok*)
  | `Str_lit of string_literal (*tok*)
  | `Date of date (*tok*)
  | `Date_time of date_time (*tok*)
  | `Bool of boolean
  | `Date_lit of date_literal
  | `Date_lit_with_param of (
        tok_choice_pat_last_n_days * Token.t (* ":" *) * int_ (*tok*)
    )
  | `Curr_lit of currency_literal (*tok*)
  | `Null_lit of null_literal
]

type field_identifier = [
    `Id of identifier
  | `Dotted_id of (
        identifier
      * (Token.t (* "." *) * identifier) list (* one or more *)
    )
]

type anon_choice_id_73106c9 = [
    `Id of identifier
  | `Apex_meth_id of (identifier * Token.t (* "(" *) * Token.t (* ")" *))
]

type with_data_cat_filter = (
    identifier
  * with_data_cat_filter_type
  * [ `Id of identifier | `LPAR_id_rep_COMMA_id_RPAR of inferred_parameters ]
)

type storage_identifier = [
    `Semg_ellips of Token.t (* "..." *)
  | `Semg_meta_ellips of semgrep_metavar_ellipsis (*tok*)
  | `Choice_id of field_identifier
]

type field_list = (
    field_identifier
  * (Token.t (* "," *) * field_identifier) list (* zero or more *)
)

type with_data_cat_expression = (
    pat_data
  * pat_cate
  * with_data_cat_filter
  * (pat_and * with_data_cat_filter) list (* zero or more *)
)

type when_expression = (pat_when * identifier * pat_then * field_list)

type else_expression = (pat_else * field_list)

type soql_with_type = [
    `Pat_secu_enfo of pat_secu_enfo
  | `Pat_user_mode of pat_user_mode
  | `Pat_system_mode of pat_system_mode
  | `With_record_visi_exp of (
        pat_reco
      * Token.t (* "(" *)
      * with_record_visibility_param
      * (Token.t (* "," *) * with_record_visibility_param)
          list (* zero or more *)
      * Token.t (* ")" *)
    )
  | `With_data_cat_exp of with_data_cat_expression
  | `With_user_id_type of (
        pat_userid * Token.t (* "=" *) * string_literal (*tok*)
    )
]

type anon_choice_stor_id_355c95c = [
    `Stor_id of storage_identifier
  | `Stor_alias of (storage_identifier * pat_as option * identifier)
]

type type_of_clause = (
    pat_typeof
  * identifier
  * when_expression list (* zero or more *)
  * else_expression option
  * pat_end
)

type soql_with_clause = (pat_with * soql_with_type)

type from_clause = (
    pat_from
  * anon_choice_stor_id_355c95c
  * (Token.t (* "," *) * anon_choice_stor_id_355c95c) list (* zero or more *)
)

type accessor_declaration = (
    modifiers option
  * [ `Pat_get of pat_get | `Pat_set of pat_set ]
  * anon_choice_trig_body_f78fea4
)

and accessor_list = (
    Token.t (* "{" *)
  * accessor_declaration list (* one or more *)
  * Token.t (* "}" *)
)

and alias_expression = (value_expression * pat_as option * identifier)

and annotation = (Token.t (* "@" *) * name * annotation_argument_list option)

and annotation_argument_list = (
    Token.t (* "(" *)
  * [
        `Elem_value of element_value
      | `Anno_key_value_rep_opt_COMMA_anno_key_value of (
            annotation_key_value
          * (Token.t (* "," *) option * annotation_key_value)
              list (* zero or more *)
        )
    ]
  * Token.t (* ")" *)
)

and annotation_key_value = [
    `Semg_ellips of Token.t (* "..." *)
  | `Id_EQ_elem_value of (identifier * Token.t (* "=" *) * element_value)
]

and anon_LPAR_choice_soql_lit_rep_COMMA_choice_soql_lit_RPAR_bea6d78 = (
    Token.t (* "(" *)
  * anon_choice_soql_lit_3019e24
  * (Token.t (* "," *) * anon_choice_soql_lit_3019e24)
      list (* zero or more *)
  * Token.t (* ")" *)
)

and anon_choice_field_id_cb081aa = [
    `Field_id of field_identifier
  | `Func_exp of function_expression
]

and anon_choice_int_1466488 = [
    `Int of int_ (*tok*)
  | `Bound_apex_exp of bound_apex_expression
]

and anon_choice_prim_exp_bbf4eda = [
    `Prim_exp of primary_expression
  | `Super of super
]

and anon_choice_semg_ellips_d10ab47 = [
    `Semg_ellips of Token.t (* "..." *)
  | `Semg_meta_ellips of semgrep_metavar_ellipsis (*tok*)
  | `Exp of expression
]

and anon_choice_soql_lit_3019e24 = [
    `Soql_lit of soql_literal
  | `Bound_apex_exp of bound_apex_expression
]

and anon_choice_trig_body_f78fea4 = [
    `Blk of trigger_body
  | `SEMI of Token.t (* ";" *)
]

and anon_exp_rep_COMMA_exp_0bb260c = (
    expression
  * (Token.t (* "," *) * expression) list (* zero or more *)
)

and argument_list = (
    Token.t (* "(" *)
  * (
        anon_choice_semg_ellips_d10ab47
      * (Token.t (* "," *) * anon_choice_semg_ellips_d10ab47)
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and array_access = (
    primary_expression * Token.t (* "[" *) * expression * Token.t (* "]" *)
)

and array_creation_expression = (
    pat_new
  * simple_type
  * [
        `Rep1_dimens_expr_opt_dimens of (
            dimensions_expr list (* one or more *)
          * dimensions option
        )
      | `Dimens_array_init of (dimensions * array_initializer)
      | `Array_init of array_initializer
    ]
)

and array_initializer = (
    Token.t (* "{" *)
  * (
        variable_initializer
      * (Token.t (* "," *) * variable_initializer) list (* zero or more *)
    )
      option
  * Token.t (* "}" *)
)

and binary_expression = [
    `Exp_GT_exp of (expression * Token.t (* ">" *) * expression)
  | `Exp_LT_exp of (expression * Token.t (* "<" *) * expression)
  | `Exp_GTEQ_exp of (expression * Token.t (* ">=" *) * expression)
  | `Exp_LTEQ_exp of (expression * Token.t (* "<=" *) * expression)
  | `Exp_EQEQ_exp of (expression * Token.t (* "==" *) * expression)
  | `Exp_EQEQEQ_exp of (expression * Token.t (* "===" *) * expression)
  | `Exp_BANGEQ_exp of (expression * Token.t (* "!=" *) * expression)
  | `Exp_LTGT_exp of (expression * Token.t (* "<>" *) * expression)
  | `Exp_BANGEQEQ_exp of (expression * Token.t (* "!==" *) * expression)
  | `Exp_AMPAMP_exp of (expression * Token.t (* "&&" *) * expression)
  | `Exp_BARBAR_exp of (expression * Token.t (* "||" *) * expression)
  | `Exp_PLUS_exp of (expression * Token.t (* "+" *) * expression)
  | `Exp_DASH_exp of (expression * Token.t (* "-" *) * expression)
  | `Exp_STAR_exp of (expression * Token.t (* "*" *) * expression)
  | `Exp_SLASH_exp of (expression * Token.t (* "/" *) * expression)
  | `Exp_AMP_exp of (expression * Token.t (* "&" *) * expression)
  | `Exp_BAR_exp of (expression * Token.t (* "|" *) * expression)
  | `Exp_HAT_exp of (expression * Token.t (* "^" *) * expression)
  | `Exp_PERC_exp of (expression * Token.t (* "%" *) * expression)
  | `Exp_LTLT_exp of (expression * Token.t (* "<<" *) * expression)
  | `Exp_GTGT_exp of (expression * Token.t (* ">>" *) * expression)
  | `Exp_GTGTGT_exp of (expression * Token.t (* ">>>" *) * expression)
]

and block = (
    Token.t (* "{" *)
  * statement list (* zero or more *)
  * Token.t (* "}" *)
)

and boolean_expression = [
    `And_exp of (
        condition_expression
      * (pat_and * condition_expression) list (* one or more *)
    )
  | `Or_exp of (
        condition_expression
      * (pat_or * condition_expression) list (* one or more *)
    )
  | `Not_exp of (pat_not * condition_expression)
  | `Cond_exp of condition_expression
]

and bound_apex_expression = (Token.t (* ":" *) * expression)

and catch_clause = (
    pat_catch * Token.t (* "(" *) * catch_formal_parameter
  * Token.t (* ")" *) * trigger_body
)

and catch_formal_parameter = [
    `Semg_ellips of Token.t (* "..." *)
  | `Opt_modifs_unan_type_var_decl_id of (
        modifiers option
      * unannotated_type
      * variable_declarator_id
    )
]

and class_body = (
    Token.t (* "{" *)
  * class_body_declaration list (* zero or more *)
  * Token.t (* "}" *)
)

and class_body_declaration = [
    `Semg_ellips of Token.t (* "..." *)
  | `Choice_field_decl of [
        `Field_decl of field_declaration
      | `Meth_decl of method_declaration
      | `Class_decl of class_declaration
      | `Inte_decl of interface_declaration
      | `Enum_decl of enum_declaration
      | `Blk of trigger_body
      | `Static_init of static_initializer
      | `Cons_decl of constructor_declaration
      | `SEMI of Token.t (* ";" *)
    ]
]

and class_declaration = (class_header * class_body)

and class_header = (
    modifiers option
  * pat_class
  * identifier
  * type_parameters option
  * superclass option
  * interfaces option
)

and class_literal = (unannotated_type * Token.t (* "." *) * pat_class)

and comparison = [
    `Value_comp of (value_comparison_operator * anon_choice_soql_lit_3019e24)
  | `Set_comp of (
        set_comparison_operator
      * [
            `Subq of subquery
          | `LPAR_choice_soql_lit_rep_COMMA_choice_soql_lit_RPAR of
              anon_LPAR_choice_soql_lit_rep_COMMA_choice_soql_lit_RPAR_bea6d78
          | `Bound_apex_exp of bound_apex_expression
        ]
    )
]

and comparison_expression = (value_expression * comparison)

and condition_expression = [
    `Semg_meta of semgrep_metavar (*tok*)
  | `Choice_LPAR_bool_exp_RPAR of [
        `LPAR_bool_exp_RPAR of (
            Token.t (* "(" *) * boolean_expression * Token.t (* ")" *)
        )
      | `Comp_exp of comparison_expression
    ]
]

and constant_declaration = (
    modifiers option
  * unannotated_type
  * variable_declarator_list
  * Token.t (* ";" *)
)

and constructor_body = (
    Token.t (* "{" *)
  * explicit_constructor_invocation option
  * statement list (* zero or more *)
  * Token.t (* "}" *)
)

and constructor_declaration = (
    modifiers option
  * constructor_declarator
  * constructor_body
)

and constructor_declarator = (
    type_parameters option
  * identifier
  * formal_parameters
)

and declaration = [
    `Class_decl of class_declaration
  | `Trig_decl of (
        pat_trig
      * identifier
      * pat_on
      * identifier
      * Token.t (* "(" *)
      * trigger_event
      * (Token.t (* "," *) * trigger_event) list (* zero or more *)
      * Token.t (* ")" *)
      * trigger_body
    )
  | `Inte_decl of interface_declaration
  | `Enum_decl of enum_declaration
]

and dimensions_expr = (Token.t (* "[" *) * expression * Token.t (* "]" *))

and dml_expression = [
    `Dml_type_exp of (dml_type * expression)
  | `Pat_upsert_exp_opt_unan_type of (
        pat_upsert
      * expression
      * unannotated_type option
    )
  | `Pat_merge_exp_SPACE_exp of (
        pat_merge * expression * Token.t (* " " *) * expression
    )
]

and do_statement = (
    pat_do * statement * pat_while * parenthesized_expression
  * Token.t (* ";" *)
)

and element_value = [
    `Exp of expression
  | `Elem_value_array_init of (
        Token.t (* "{" *)
      * (
            element_value
          * (Token.t (* "," *) * element_value) list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
      * Token.t (* "}" *)
    )
  | `Anno of annotation
]

and enhanced_for_statement = (
    pat_for
  * Token.t (* "(" *)
  * modifiers option
  * unannotated_type
  * variable_declarator_id
  * Token.t (* ":" *)
  * expression
  * Token.t (* ")" *)
  * statement
)

and enum_body = (
    Token.t (* "{" *)
  * (
        enum_constant
      * (Token.t (* "," *) * enum_constant) list (* zero or more *)
    )
      option
  * Token.t (* "}" *)
)

and enum_constant = [
    `Semg_ellips of Token.t (* "..." *)
  | `Opt_modifs_id of (modifiers option * identifier)
]

and enum_declaration = (
    modifiers option
  * pat_enum
  * identifier
  * interfaces option
  * enum_body
)

and explicit_constructor_invocation = (
    [
        `Opt_type_args_choice_this of (
            type_arguments option
          * [ `This of this | `Super of super ]
        )
      | `Choice_prim_exp_DOT_opt_type_args_super of (
            [ `Prim_exp of primary_expression ]
          * Token.t (* "." *)
          * type_arguments option
          * super
        )
    ]
  * argument_list
  * Token.t (* ";" *)
)

and expression = [
    `Assign_exp of (
        [
            `Id of identifier
          | `Field_access of field_access
          | `Array_access of array_access
        ]
      * [
            `EQ of Token.t (* "=" *)
          | `PLUSEQ of Token.t (* "+=" *)
          | `DASHEQ of Token.t (* "-=" *)
          | `STAREQ of Token.t (* "*=" *)
          | `SLASHEQ of Token.t (* "/=" *)
          | `AMPEQ of Token.t (* "&=" *)
          | `BAREQ of Token.t (* "|=" *)
          | `HATEQ of Token.t (* "^=" *)
          | `PERCEQ of Token.t (* "%=" *)
          | `LTLTEQ of Token.t (* "<<=" *)
          | `GTGTEQ of Token.t (* ">>=" *)
          | `GTGTGTEQ of Token.t (* ">>>=" *)
        ]
      * expression
    )
  | `Bin_exp of binary_expression
  | `Inst_exp of (expression * pat_inst * type_)
  | `Tern_exp of (
        expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
      * expression
    )
  | `Update_exp of update_expression
  | `Prim_exp of primary_expression
  | `Un_exp of unary_expression
  | `Cast_exp of (Token.t (* "(" *) * type_ * Token.t (* ")" *) * expression)
  | `Dml_exp of dml_expression
  | `Switch_exp of switch_expression
]

and expression_statement = (expression * Token.t (* ";" *))

and extends_interfaces = (pat_extends * type_list)

and field_access = (
    anon_choice_prim_exp_bbf4eda
  * (property_navigation * super) option
  * property_navigation
  * [ `Id of identifier | `This of this ]
)

and field_declaration = (
    modifiers option
  * unannotated_type
  * variable_declarator_list
  * [ `Acce_list of accessor_list | `SEMI of Token.t (* ";" *) ]
)

and finally_clause = (pat_fina * trigger_body)

and find_clause = (
    pat_find
  * [
        `Bound_apex_exp of bound_apex_expression
      | `Term_sepa_start_term_term_sepa_end of (
            Token.t (* "'" *) * term (*tok*) * Token.t (* "'" *)
        )
    ]
)

and for_statement = (
    pat_for
  * Token.t (* "(" *)
  * [
        `Semg_ellips of Token.t (* "..." *)
      | `Choice_local_var_decl_opt_exp_SEMI_opt_exp_rep_COMMA_exp of (
            [
                `Local_var_decl of local_variable_declaration
              | `Opt_exp_rep_COMMA_exp_SEMI of (
                    anon_exp_rep_COMMA_exp_0bb260c option
                  * Token.t (* ";" *)
                )
            ]
          * expression option
          * Token.t (* ";" *)
          * anon_exp_rep_COMMA_exp_0bb260c option
        )
    ]
  * Token.t (* ")" *)
  * statement
)

and formal_parameter = [
    `Opt_modifs_unan_type_var_decl_id of (
        modifiers option
      * unannotated_type
      * variable_declarator_id
    )
  | `Semg_ellips of Token.t (* "..." *)
  | `Semg_meta_ellips of semgrep_metavar_ellipsis (*tok*)
]

and formal_parameters = (
    Token.t (* "(" *)
  * (
        formal_parameter
      * (Token.t (* "," *) * formal_parameter) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and function_expression = [
    `Pat_dist_LPAR_choice_field_id_COMMA_geo_loca_type_COMMA_str_lit_RPAR of (
        pat_dist
      * Token.t (* "(" *)
      * [
            `Field_id of field_identifier
          | `Bound_apex_exp of bound_apex_expression
        ]
      * Token.t (* "," *)
      * geo_location_type
      * Token.t (* "," *)
      * string_literal (*tok*)
      * Token.t (* ")" *)
    )
  | `Func_name_LPAR_value_exp_RPAR of (
        function_name * Token.t (* "(" *) * value_expression
      * Token.t (* ")" *)
    )
]

and generic_type = (
    [ `Id of identifier | `Scoped_type_id of scoped_type_identifier ]
  * type_arguments
)

and geo_location_type = [
    `Field_id of field_identifier
  | `Bound_apex_exp of bound_apex_expression
  | `Pat_geol_LPAR_deci_COMMA_deci_RPAR of (
        pat_geol * Token.t (* "(" *) * decimal (*tok*) * Token.t (* "," *)
      * decimal (*tok*) * Token.t (* ")" *)
    )
]

and group_by_clause = (
    pat_group
  * pat_by
  * group_by_expression
  * having_clause option
)

and group_by_expression = [
    `Choice_field_id_rep_COMMA_choice_field_id of (
        anon_choice_field_id_cb081aa
      * (Token.t (* "," *) * anon_choice_field_id_cb081aa)
          list (* zero or more *)
    )
  | `Choice_pat_rollup_LPAR_field_id_rep_COMMA_field_id_RPAR of (
        [ `Pat_rollup of pat_rollup | `Pat_cube of pat_cube ]
      * Token.t (* "(" *)
      * field_identifier
      * (Token.t (* "," *) * field_identifier) list (* zero or more *)
      * Token.t (* ")" *)
    )
]

and having_boolean_expression = [
    `Having_and_exp of (
        having_condition_expression
      * (pat_and * having_condition_expression) list (* one or more *)
    )
  | `Having_or_exp of (
        having_condition_expression
      * (pat_or * having_condition_expression) list (* one or more *)
    )
  | `Having_not_exp of (pat_not * having_condition_expression)
  | `Having_cond_exp of having_condition_expression
]

and having_clause = (pat_having * having_boolean_expression)

and having_comparison = [
    `Having_value_comp of (
        value_comparison_operator * anon_choice_soql_lit_3019e24
    )
  | `Having_set_comp of (
        set_comparison_operator
      * [
            `LPAR_choice_soql_lit_rep_COMMA_choice_soql_lit_RPAR of
              anon_LPAR_choice_soql_lit_rep_COMMA_choice_soql_lit_RPAR_bea6d78
          | `Bound_apex_exp of bound_apex_expression
        ]
    )
]

and having_condition_expression = [
    `LPAR_having_bool_exp_RPAR of (
        Token.t (* "(" *) * having_boolean_expression * Token.t (* ")" *)
    )
  | `Having_comp_exp of (function_expression * having_comparison)
]

and if_statement = (
    pat_if
  * parenthesized_expression
  * statement
  * (pat_else * statement) option
)

and interface_body = (
    Token.t (* "{" *)
  * [
        `Semg_ellips of Token.t (* "..." *)
      | `Cst_decl of constant_declaration
      | `Enum_decl of enum_declaration
      | `Meth_decl of method_declaration
      | `Class_decl of class_declaration
      | `Inte_decl of interface_declaration
      | `SEMI of Token.t (* ";" *)
    ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

and interface_declaration = (
    modifiers option
  * pat_inte
  * identifier
  * type_parameters option
  * extends_interfaces option
  * interface_body
)

and interfaces = (pat_imples * type_list)

and labeled_statement = (identifier * Token.t (* ":" *) * statement)

and limit_clause = (pat_limit * anon_choice_int_1466488)

and local_variable_declaration = (
    modifiers option
  * unannotated_type
  * variable_declarator_list
  * Token.t (* ";" *)
)

and map_creation_expression = (pat_new * simple_type * map_initializer)

and map_initializer = (
    Token.t (* "{" *)
  * (
        map_initializer_
      * (Token.t (* "," *) * map_initializer_) list (* zero or more *)
    )
      option
  * Token.t (* "}" *)
)

and map_initializer_ = (expression * Token.t (* "=>" *) * expression)

and method_declaration = (
    modifiers option
  * method_header
  * anon_choice_trig_body_f78fea4
)

and method_declarator = (identifier * formal_parameters * dimensions option)

and method_header = (
    (type_parameters * annotation list (* zero or more *)) option
  * unannotated_type
  * method_declarator
)

and method_invocation = (
    [
        `Id of identifier
      | `Choice_prim_exp_prop_navi_opt_super_prop_navi_opt_type_args_id of (
            anon_choice_prim_exp_bbf4eda
          * property_navigation
          * (super * property_navigation) option
          * type_arguments option
          * identifier
        )
    ]
  * argument_list
)

and modifiers =
  [ `Anno of annotation | `Modi of modifier ] list (* one or more *)

and object_creation_expression = unqualified_object_creation_expression

and offset_clause = (pat_offset * anon_choice_int_1466488)

and order_by_clause = (
    pat_order
  * pat_by
  * order_expression
  * (Token.t (* "," *) * order_expression) list (* zero or more *)
)

and order_expression = (
    value_expression
  * order_direction option
  * order_null_direciton option
)

and parenthesized_expression = (
    Token.t (* "(" *) * expression * Token.t (* ")" *)
)

and partial_catch = catch_clause

and partial_finally = finally_clause

and primary_expression = [
    `Choice_lit of [
        `Lit of literal
      | `Class_lit of class_literal
      | `This of this
      | `Id of identifier
      | `Paren_exp of parenthesized_expression
      | `Obj_crea_exp of object_creation_expression
      | `Field_access of field_access
      | `Array_access of array_access
      | `Meth_invo of method_invocation
      | `Array_crea_exp of array_creation_expression
      | `Map_crea_exp of map_creation_expression
      | `Query_exp of query_expression
    ]
  | `Semg_deep_exp of (
        Token.t (* "<..." *) * expression * Token.t (* "...>" *)
    )
]

and query_expression = (
    Token.t (* "[" *)
  * [ `Soql_query of soql_query | `Sosl_query of sosl_query ]
  * Token.t (* "]" *)
)

and query_expression_ = sosl_query_body

and return_statement = (pat_ret * expression option * Token.t (* ";" *))

and returning_clause = (
    pat_retu
  * sobject_return
  * (Token.t (* "," *) * sobject_return) list (* zero or more *)
)

and run_as_statement = (
    pat_e8c36c5 * parenthesized_expression * trigger_body
)

and scoped_type_identifier = (
    [
        `Id of identifier
      | `Scoped_type_id of scoped_type_identifier
      | `Gene_type of generic_type
    ]
  * Token.t (* "." *)
  * annotation list (* zero or more *)
  * identifier
)

and select_clause = (
    pat_select
  * [
        `Count_exp of count_expression
      | `Sele_exp_rep_COMMA_sele_exp of selected_fields
    ]
)

and selectable_expression = [
    `Semg_ellips of Token.t (* "..." *)
  | `Semg_meta_ellips of semgrep_metavar_ellipsis (*tok*)
  | `Choice_value_exp of [
        `Value_exp of value_expression
      | `Alias_exp of alias_expression
      | `Type_of_clause of type_of_clause
      | `Fields_exp of fields_expression
      | `Subq of subquery
    ]
]

and selected_fields = (
    selectable_expression
  * (Token.t (* "," *) * selectable_expression) list (* zero or more *)
)

and simple_type = [
    `Void_type of void_type
  | `Bool_type of Token.t (* "boolean" *)
  | `Id of identifier
  | `Scoped_type_id of scoped_type_identifier
  | `Gene_type of generic_type
]

and sobject_return = (
    identifier
  * (
        Token.t (* "(" *)
      * selected_fields
      * using_clause option
      * where_clause option
      * order_by_clause option
      * limit_clause option
      * offset_clause option
      * Token.t (* ")" *)
    )
      option
)

and soql_query = soql_query_expression

and soql_query_body = (
    select_clause
  * from_clause
  * soql_using_clause option
  * where_clause option
  * soql_with_clause option
  * group_by_clause option
  * order_by_clause option
  * limit_clause option
  * offset_clause option
  * for_clause option
  * update_clause option
  * all_rows_clause option
)

and soql_query_expression = soql_query_body

and sosl_query = query_expression_

and sosl_query_body = (
    find_clause
  * in_clause option
  * returning_clause list (* zero or more *) option
  * sosl_with_clause list (* zero or more *) option
  * limit_clause option
  * offset_clause option
  * update_clause option
)

and sosl_with_clause = (pat_with * sosl_with_type)

and sosl_with_type = [
    `With_data_cat_exp of with_data_cat_expression
  | `With_divi_exp of (
        pat_divi
      * Token.t (* "=" *)
      * [
            `Bound_apex_exp of bound_apex_expression
          | `Str_lit of string_literal (*tok*)
        ]
    )
  | `With_high of with_highlight
  | `With_meta_exp of (pat_meta * Token.t (* "=" *) * string_literal (*tok*))
  | `With_netw_exp of (pat_netw * comparison)
  | `With_pric_exp of (pat_pric * Token.t (* "=" *) * string_literal (*tok*))
  | `With_snip_exp of (
        pat_snip
      * (
            Token.t (* "(" *) * pat_target_len * Token.t (* "=" *)
          * int_ (*tok*) * Token.t (* ")" *)
        )
          option
    )
  | `With_spell_corr_exp of (pat_spell_corr * Token.t (* "=" *) * boolean)
]

and statement = [
    `Choice_decl of [
        `Decl of declaration
      | `Exp_stmt of expression_statement
      | `Labe_stmt of labeled_statement
      | `If_stmt of if_statement
      | `While_stmt of while_statement
      | `For_stmt of for_statement
      | `Enha_for_stmt of enhanced_for_statement
      | `Blk of trigger_body
      | `SEMI of Token.t (* ";" *)
      | `Do_stmt of do_statement
      | `Brk_stmt of break_statement
      | `Cont_stmt of continue_statement
      | `Ret_stmt of return_statement
      | `Switch_exp of switch_expression
      | `Local_var_decl of local_variable_declaration
      | `Throw_stmt of throw_statement
      | `Try_stmt of try_statement
      | `Run_as_stmt of run_as_statement
    ]
  | `Semg_ellips of Token.t (* "..." *)
]

and static_initializer = (pat_static * trigger_body)

and subquery = (
    Token.t (* "(" *) * soql_query_expression * Token.t (* ")" *)
)

and superclass = (pat_extends * type_)

and switch_block = (
    Token.t (* "{" *)
  * switch_rule list (* one or more *)
  * Token.t (* "}" *)
)

and switch_expression = (pat_switch * pat_on * expression * switch_block)

and switch_label = (
    pat_when
  * [
        `Opt_unan_type_id_rep_COMMA_opt_unan_type_id of (
            unannotated_type option
          * identifier
          * (Token.t (* "," *) * unannotated_type option * identifier)
              list (* zero or more *)
        )
      | `Exp_rep_COMMA_exp of anon_exp_rep_COMMA_exp_0bb260c
      | `Pat_else of pat_else
    ]
)

and switch_rule = [
    `Semg_ellips of Token.t (* "..." *)
  | `Switch_label_blk of (switch_label * trigger_body)
]

and throw_statement = (pat_throw * expression * Token.t (* ";" *))

and trigger_body = block

and try_statement = (
    pat_try
  * trigger_body
  * [
        `Rep1_catch_clause of partial_catch list (* one or more *)
      | `Rep_catch_clause_fina_clause of (
            partial_catch list (* zero or more *)
          * partial_finally
        )
    ]
)

and type_ = [
    `Unan_type of unannotated_type
  | `Anno_type of (annotation list (* one or more *) * unannotated_type)
]

and type_arguments = (
    Token.t (* "<" *)
  * type_list option
  * Token.t (* ">" *)
)

and type_bound = (
    pat_extends
  * type_
  * (Token.t (* "&" *) * type_) list (* zero or more *)
)

and type_list = (type_ * (Token.t (* "," *) * type_) list (* zero or more *))

and type_parameter = [
    `Semg_ellips of Token.t (* "..." *)
  | `Rep_anno_id_opt_type_bound of (
        annotation list (* zero or more *)
      * identifier
      * type_bound option
    )
]

and type_parameters = (
    Token.t (* "<" *)
  * type_parameter
  * (Token.t (* "," *) * type_parameter) list (* zero or more *)
  * Token.t (* ">" *)
)

and unannotated_type = [
    `Choice_void_type of simple_type
  | `Array_type of (unannotated_type * dimensions)
]

and unary_expression = [
    `PLUS_exp of (Token.t (* "+" *) * expression)
  | `DASH_exp of (Token.t (* "-" *) * expression)
  | `BANG_exp of (Token.t (* "!" *) * expression)
  | `TILDE_exp of (Token.t (* "~" *) * expression)
]

and unqualified_object_creation_expression = (
    pat_new
  * type_arguments option
  * simple_type
  * argument_list
  * class_body option
)

and update_expression = [
    `Exp_PLUSPLUS of (expression * Token.t (* "++" *))
  | `Exp_DASHDASH of (expression * Token.t (* "--" *))
  | `PLUSPLUS_exp of (Token.t (* "++" *) * expression)
  | `DASHDASH_exp of (Token.t (* "--" *) * expression)
]

and value_expression = [
    `Func_exp of function_expression
  | `Field_id of field_identifier
]

and variable_declarator = (
    variable_declarator_id
  * (Token.t (* "=" *) * variable_initializer) option
)

and variable_declarator_list = (
    variable_declarator
  * (Token.t (* "," *) * variable_declarator) list (* zero or more *)
)

and variable_initializer = [
    `Exp of expression
  | `Array_init of array_initializer
]

and where_clause = (pat_where * boolean_expression)

and while_statement = (pat_while * parenthesized_expression * statement)

type parser_output = [
    `Rep_stmt of statement list (* zero or more *)
  | `Cons_decl of constructor_declaration
  | `Exp of expression
  | `Anno of annotation
  | `Meth_decl of method_declaration
  | `Local_var_decl of local_variable_declaration
  | `Class_header of class_header
  | `Full_meth_header of (modifiers option * method_header)
  | `Part_if of (pat_if * parenthesized_expression)
  | `Part_try of (pat_try * trigger_body)
  | `Part_catch of partial_catch
  | `Part_fina of partial_finally
]

type term_separator_end (* inlined *) = Token.t (* "'" *)

type term_separator_start (* inlined *) = Token.t (* "'" *)

type semgrep_ellipsis (* inlined *) = Token.t (* "..." *)

type boolean_type (* inlined *) = Token.t (* "boolean" *)

type with_metadata_expression (* inlined *) = (
    pat_meta * Token.t (* "=" *) * string_literal (*tok*)
)

type comment (* inlined *) = [
    `Line_comm_expl of line_comment_explicit (*tok*)
  | `Blk_comm_expl of block_comment_explicit (*tok*)
]

type semgrep_any_ellipsis (* inlined *) = [
    `Semg_ellips of Token.t (* "..." *)
  | `Semg_meta_ellips of semgrep_metavar_ellipsis (*tok*)
]

type dummy_alias0 (* inlined *) = block_comment (*tok*)

type with_pricebook_expression (* inlined *) = (
    pat_pric * Token.t (* "=" *) * string_literal (*tok*)
)

type with_user_id_type (* inlined *) = (
    pat_userid * Token.t (* "=" *) * string_literal (*tok*)
)

type date_literal_with_param (* inlined *) = (
    tok_choice_pat_last_n_days * Token.t (* ":" *) * int_ (*tok*)
)

type with_snippet_expression (* inlined *) = (
    pat_snip
  * (
        Token.t (* "(" *) * pat_target_len * Token.t (* "=" *) * int_ (*tok*)
      * Token.t (* ")" *)
    )
      option
)

type dummy_alias1 (* inlined *) = line_comment (*tok*)

type dotted_identifier (* inlined *) = (
    identifier
  * (Token.t (* "." *) * identifier) list (* one or more *)
)

type apex_method_identifier (* inlined *) = (
    identifier * Token.t (* "(" *) * Token.t (* ")" *)
)

type scoped_identifier (* inlined *) = (
    name * Token.t (* "." *) * identifier
)

type with_spell_correction_expression (* inlined *) = (
    pat_spell_corr * Token.t (* "=" *) * boolean
)

type with_record_visibility_expression (* inlined *) = (
    pat_reco
  * Token.t (* "(" *)
  * with_record_visibility_param
  * (Token.t (* "," *) * with_record_visibility_param)
      list (* zero or more *)
  * Token.t (* ")" *)
)

type apex_identifier (* inlined *) = (
    anon_choice_id_73106c9
  * (Token.t (* "?" *) option * Token.t (* "." *) * anon_choice_id_73106c9)
      list (* zero or more *)
)

type storage_alias (* inlined *) = (
    storage_identifier
  * pat_as option
  * identifier
)

type and_expression (* inlined *) = (
    condition_expression
  * (pat_and * condition_expression) list (* one or more *)
)

type annotated_type (* inlined *) = (
    annotation list (* one or more *)
  * unannotated_type
)

type array_type (* inlined *) = (unannotated_type * dimensions)

type assignment_expression (* inlined *) = (
    [
        `Id of identifier
      | `Field_access of field_access
      | `Array_access of array_access
    ]
  * [
        `EQ of Token.t (* "=" *)
      | `PLUSEQ of Token.t (* "+=" *)
      | `DASHEQ of Token.t (* "-=" *)
      | `STAREQ of Token.t (* "*=" *)
      | `SLASHEQ of Token.t (* "/=" *)
      | `AMPEQ of Token.t (* "&=" *)
      | `BAREQ of Token.t (* "|=" *)
      | `HATEQ of Token.t (* "^=" *)
      | `PERCEQ of Token.t (* "%=" *)
      | `LTLTEQ of Token.t (* "<<=" *)
      | `GTGTEQ of Token.t (* ">>=" *)
      | `GTGTGTEQ of Token.t (* ">>>=" *)
    ]
  * expression
)

type cast_expression (* inlined *) = (
    Token.t (* "(" *) * type_ * Token.t (* ")" *) * expression
)

type element_value_array_initializer (* inlined *) = (
    Token.t (* "{" *)
  * (
        element_value
      * (Token.t (* "," *) * element_value) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

type having_and_expression (* inlined *) = (
    having_condition_expression
  * (pat_and * having_condition_expression) list (* one or more *)
)

type having_comparison_expression (* inlined *) = (
    function_expression * having_comparison
)

type having_not_expression (* inlined *) = (
    pat_not * having_condition_expression
)

type having_or_expression (* inlined *) = (
    having_condition_expression
  * (pat_or * having_condition_expression) list (* one or more *)
)

type having_set_comparison (* inlined *) = (
    set_comparison_operator
  * [
        `LPAR_choice_soql_lit_rep_COMMA_choice_soql_lit_RPAR of
          anon_LPAR_choice_soql_lit_rep_COMMA_choice_soql_lit_RPAR_bea6d78
      | `Bound_apex_exp of bound_apex_expression
    ]
)

type having_value_comparison (* inlined *) = (
    value_comparison_operator * anon_choice_soql_lit_3019e24
)

type instanceof_expression (* inlined *) = (expression * pat_inst * type_)

type not_expression (* inlined *) = (pat_not * condition_expression)

type or_expression (* inlined *) = (
    condition_expression
  * (pat_or * condition_expression) list (* one or more *)
)

type semgrep_deep_expression (* inlined *) = (
    Token.t (* "<..." *) * expression * Token.t (* "...>" *)
)

type set_comparison (* inlined *) = (
    set_comparison_operator
  * [
        `Subq of subquery
      | `LPAR_choice_soql_lit_rep_COMMA_choice_soql_lit_RPAR of
          anon_LPAR_choice_soql_lit_rep_COMMA_choice_soql_lit_RPAR_bea6d78
      | `Bound_apex_exp of bound_apex_expression
    ]
)

type ternary_expression (* inlined *) = (
    expression * Token.t (* "?" *) * expression * Token.t (* ":" *)
  * expression
)

type trigger_declaration (* inlined *) = (
    pat_trig
  * identifier
  * pat_on
  * identifier
  * Token.t (* "(" *)
  * trigger_event
  * (Token.t (* "," *) * trigger_event) list (* zero or more *)
  * Token.t (* ")" *)
  * trigger_body
)

type value_comparison (* inlined *) = (
    value_comparison_operator * anon_choice_soql_lit_3019e24
)

type with_division_expression (* inlined *) = (
    pat_divi
  * Token.t (* "=" *)
  * [
        `Bound_apex_exp of bound_apex_expression
      | `Str_lit of string_literal (*tok*)
    ]
)

type with_network_expression (* inlined *) = (pat_netw * comparison)

type full_method_header (* inlined *) = (modifiers option * method_header)

type default_value (* inlined *) = (Token.t (* "default" *) * element_value)

type partial_if (* inlined *) = (pat_if * parenthesized_expression)

type partial_try (* inlined *) = (pat_try * trigger_body)

type extra = 
    Line_comment of Loc.t * line_comment
  | Block_comment of Loc.t * block_comment


type extras = extra list
